#+setupfile: ../settings/README.org
#+property: header-args:hy :tangle yes

Inspired by [[https://amoffat.github.io/sh/][sh]] by [[https://github.com/amoffat][Andrew Moffat]].

* Richyrich Traceback

#+begin_src hy
(import richyrich.traceback)
(.install richyrich.traceback :show-locals True)
#+end_src

* Imports

#+begin_src hy
(import builtins)
(import weakref)
#+end_src

** From

#+begin_src hy
(import addict [Dict :as D])
(import ast [literal-eval])
(import autoslot [Slots SlotsMeta])
(import collections [OrderedDict])
(import copy [copy deepcopy])
(import functools [partial wraps])
(import hy [mangle unmangle])
(import hyrule [coll? inc])
(import inspect [isclass :as class?])
(import itertools [chain filterfalse tee])
(import more-itertools [peekable])
(import oreo [eclair either? flatten get-un-mangled int? recursive-unmangle tea first-last-n])
(import os [environ path :as osPath getcwd])
(import richyrich [print inspect])
(import richyrich.pretty [pretty-repr pprint])
(import richyrich.progress [Progress])
(import shlex [join split])
(import shutil [which])
(import subprocess [DEVNULL PIPE Popen STDOUT])
(import textwrap [TextWrapper])
(import types [MethodType])
#+end_src

*** Coconut

[[https://coconut.readthedocs.io/en/latest/index.html][Coconut]]:

#+begin_src hy
(try (import coconut *)
     (except [ImportError] None))
#+end_src

*** Toolz

[[https://github.com/pytoolz/toolz][Toolz]] and [[https://github.com/pytoolz/cytoolz/][CyToolz]]:

#+begin_src hy
(try (import cytoolz [first])
     (except [ImportError]
             (import toolz [first])))
#+end_src

* Requires

#+begin_src hy
(require hyrule [-> assoc unless])
#+end_src

* Static Methods
** Split and Flatten Iterable

#+begin_src hy
(defn split-and-flatten [iterable] (flatten (gfor j (flatten iterable) (.split j))))
#+end_src

** Check Program

#+begin_src hy
(defn check [self program] (-> program
                          (which)
                          (is None)
                          (if None self)
                          (return)))
#+end_src

* The Frosting Class

#+begin_src hy
(defclass frosting [tea Slots]
#+end_src

** __init__

#+begin_src hy
(defn __init__ [self output [capture "stdout"]]
      (setv self.capture (if (= capture "stderr") "stderr" "stdout")
            self.dict-like (isinstance output dict)
            self.iterable (coll? output)
            self.output output)
#+end_src

*** Initialize Super

#+begin_src hy
(cond [self.dict-like (.__init__ (super) #** self.output)]
      [self.iterable (.__init__ (super) #* self.output)]
      [True (.__init__ (super) self.output)])
#+end_src

*** End of __init__

#+begin_src hy
)
#+end_src

** __iter__

#+begin_src hy
(defn __iter__ [self]
      (yield-from (if self.dict-like
                      (get self self.capture)
                      (.values self))))
#+end_src

** __call__

#+begin_src hy
(defn __call__ [self]
      (return (cond [(not self.iterable) self.output]
                    [self.dict-like (D (.items self))]
                    [True (.values self)])))
#+end_src

** End of Frosting

#+begin_src hy
)
#+end_src

* The Meta Class

Adapted from [[https://stackoverflow.com/users/36433/a-coady][A. Coady's]] answer [[https://stackoverflow.com/a/1800999/10827766][here]], as well as [[https://stackoverflow.com/users/302343/timur][Timur's]] answer [[https://stackoverflow.com/a/31537249/10827766][here]].

Remember that ~metaclasses~ use ~cls~ instead of ~self~!

#+begin_src hy
(defclass melcery [SlotsMeta]
#+end_src

** __init__

#+begin_src hy
(defn __init__ [cls #* args #** kwargs] (setv cls.m/stores [])))
#+end_src

* The Milcery Class

#+begin_src hy
(defclass milcery [:metaclass melcery]
#+end_src

Adapted from [[the man himself][https://github.com/python/typing/issues/345#issuecomment-270814750]],
as well as from the [[https://github.com/cjrh/autoslot][autoslot]] documentation (by [[https://github.com/cjrh][Caleb Hattingh]]) [[https://github.com/cjrh/autoslot#weakref][here]]:

#+begin_src hy
(setv __slots__ [ "__weakref__" ])
#+end_src

** Class Methods
*** Freezer

#+begin_src hy
#@(classmethod (defn cls/freezer [cls value freezer]
                      (cond [(not value) (setv freezer [])]
                            [(coll? value)
                             (do (unless (isinstance freezer list)
                                         (setv freezer []))
                                 (.extend freezer value)
                                 (setv freezer (flatten (gfor i freezer :if i i))))]
                            [True (raise (TypeError f"Sorry! The 'm/freezer' can only accept non-string iterables or non-truthy values!"))])
                      (return freezer)))
#+end_src

*** String Prefix

#+begin_src hy
#@(classmethod (defn cls/string-prefix [cls b a] (+ a b)))
#+end_src

*** Process Attribute

#+begin_src hy
#@(classmethod (defn cls/process-attr [cls attr prefix]
                     (setv attr (unmangle attr))
                     (if (.startswith attr prefix)
                         (.replace attr "_" "-")
                         (mangle (.replace (.cls/string-prefix cls (.lstrip attr "_") prefix) "_" "-")))))
#+end_src

*** Is Attribute

#+begin_src hy
#@(classmethod (defn cls/is-attr [cls attr]
                     (setv attr (unmangle attr))
                     (cond [(.endswith attr "__") (return "__")]
                           [(.startswith attr "__") (return "internal/")]
                           [(.startswith attr "_") (return "m/")]
                           [(.startswith attr "internal/") (return "internal/")]
                           [(.startswith attr "m/") (return "m/")]
                           [True (return False)])))
#+end_src

*** Process If Attribute

#+begin_src hy
#@(classmethod (defn cls/process-if-attr [cls attr [return-bool False]]
                     (setv attr (unmangle attr))
                     (return (if (setx prefix (.cls/is-attr cls attr))
                                 (mangle (.cls/process-attr cls attr prefix))
                                 (if return-bool False (mangle attr))))))
#+end_src

*** Remove If Not Attribute

#+begin_src hy
#@(classmethod (defn cls/remove-if-not-attr [cls dct] (return (dfor [key value] (.items dct) :if (.cls/is-attr cls key) [ key value ]))))
#+end_src

*** Trim Attribute Prefix

#+begin_src hy
#@(classmethod (defn cls/trim-attr-prefix [cls attr]
                     (setv attr (unmangle attr))
                     (let [prefix (.cls/is-attr cls attr)]
                          (return (, prefix (if prefix (mangle (.removeprefix attr prefix)) (mangle attr)))))))
#+end_src

*** Get Attribute

#+begin_src hy
#@(classmethod (defn cls/get-attr [cls dct attr [default False]]
                     (setv attr (unmangle attr))
                     (setv [prefix cls/get-attr/attr] (.cls/trim-attr-prefix cls attr))
                     (return (or (.get dct (mangle (+ "__" cls/get-attr/attr)) False)
                                 (.get dct (mangle (+ "_" cls/get-attr/attr)) False)
                                 (.get dct (mangle (+ "internal/" cls/get-attr/attr)) False)
                                 (.get dct (mangle (+ "m/" cls/get-attr/attr)) default)))))
#+end_src

** Properties
*** Freezer

This tells the bakery that the program is a combination of multiple programs, such as ~ls | tail~.

#+begin_src hy
#@(property (defn m/freezer [self] (return self.internal/freezer)))
#@(m/freezer.setter (defn m/freezer [self value] (setv self.internal/freezer (.cls/freezer self.__class__ value self.internal/freezer))))
#+end_src

*** Command
**** Return

Return the final command:

#+begin_src hy
#@(property (defn m/return-command [self] (return self.internal/return-command)))
#@(m/return-command.setter (defn m/return-command [self value]
                                 (setv self.internal/return-command (bool value))
                                 (if value (setv self.m/type str))))
#+end_src

**** Print

Print the final command:

#+begin_src hy
#@(property (defn m/print-command [self] (return self.internal/print-command)))
#@(m/print-command.setter (defn m/print-command [self value]
                                (setv self.internal/print-command (bool value))
                                (if value (setv self.m/return-command True))))
#+end_src

**** Run Interactively

#+begin_src hy
#@(property (defn m/run [self] (return (= self.m/capture "run"))))
#@(m/run.setter (defn m/run [self value] (if value (setv self.m/capture "run"))))
#+end_src

*** Output
**** Sort

Sort the output before it's converted, or if a list, return the sorted list; accepts a value of ~None~ for default sorting:

#+begin_src hy
#@(property (defn m/sort [self] (return self.internal/sort)))
#@(m/sort.setter (defn m/sort [self value]
                       (if (or (is value None)
                               value)
                           (setv dict-like (isinstance value dict)
                                 iterable (coll? value)
                                 reverse-default False
                                 key-default None
                                 self.internal/sort (D { "reverse" (cond [dict-like (.get value "reverse" reverse-default)]
                                                                         [iterable (get (or (lfor item value :if (isinstance item bool) item)
                                                                                            (, reverse-default)) 0)]
                                                                         [(isinstance value bool) value]
                                                                         [True reverse-default])
                                                         "key" (cond [dict-like (.get value "key" key-default)]
                                                                     [iterable (get (or (lfor item value :if (callable item) item)
                                                                                        (, key-default)) 0)]
                                                                     [(callable value) value]
                                                                     [True key-default]) })))))
#+end_src

**** Filter

Filter the output before it's converted:

#+begin_src hy
#@(property (defn m/filter [self] (return self.internal/filter)))
#@(m/filter.setter (defn m/filter [self value]
                         (if (or (is value None)
                                 value)
                             (setv dict-like (isinstance value dict)
                                   iterable (coll? value)
                                   reverse-default False
                                   key-default None
                                   self.internal/filter (D { "reverse" (cond [dict-like (.get value "reverse" reverse-default)]
                                                                             [iterable (get (or (lfor item value :if (isinstance item bool) item)
                                                                                                (, reverse-default)) 0)]
                                                                             [(isinstance value bool) value]
                                                                             [True reverse-default])
                                                             "key" (cond [dict-like (.get value "key" key-default)]
                                                                         [iterable (get (or (lfor item value :if (callable item) item)
                                                                                            (, key-default)) 0)]
                                                                         [(callable value) value]
                                                                         [True key-default]) })))))
#+end_src

**** Number of Lines

Shaves off the first or last ~n~ lines off of ~std~, whether that be ~stdout~ or ~stderr~:

# TODO: Split this into stdout, stderr, and both

#+begin_src hy
#@(property (defn m/n-lines [self] (return self.internal/n-lines)))
#@(m/n-lines.setter (defn m/n-lines [self value]
                       (setv dict-like (isinstance value dict)
                             iterable (coll? value)
                             last-default False
                             number-default 0
                             std-default "stdout"
                             std (cond [dict-like (.get value "std" std-default)]
                                       [iterable (get (or (lfor item value :if (isinstance item str) item)
                                                          (, std-default)) 0)]
                                       [(isinstance value str) value]
                                       [True std-default])
                             self.internal/n-lines (D {
#+end_src

Be very careful here; since ~bool~ is a subclass of ~int~, we need to first check if ~value~ is an instance of ~bool~, then ~int~,
otherwise ~(isinstance value int)~ will catch both cases.

#+begin_src hy
"last" (cond [dict-like (.get value "last" last-default)]
             [iterable (get (or (lfor item value :if (isinstance item bool) item)
                                (, last-default)) 0)]
             [(isinstance value bool) value]
             [True last-default])
"number" (cond [dict-like (.get value "number" number-default)]
               [iterable (get (or (lfor item value :if (int? item) item)
                                  (, number-default)) 0)]
               [(int? value) value]
               [True number-default])
#+end_src

#+begin_src hy
"std" (if std
          (if (not (in std (setx stds (, "stdout" "stderr" "both"))))
              (raise (TypeError #[f[Sorry! You must choose an `std' value from: {(.join ", " stds)}]f]))
              std))}))))
#+end_src

*** Context Manager

Use function as context manager:

#+begin_src hy
#@(property (defn m/c [self] (return self.m/context)))
#@(m/c.setter (defn m/c [self value] (setv self.m/context (bool value))))
#+end_src

*** Capture

Capture types, consisting of ~stdout~, ~stderr~, and both:

#+begin_src hy
#@(property (defn m/capture [self] (return self.internal/capture)))
#@(m/capture.setter (defn m/capture [self value]
                          (unless (in value self.m/captures)
                                  (raise (TypeError #[f[Sorry! Capture type "{value}" is not permitted! Choose from one of: {(.join ", " self.m/captures)}]f])))
                          (setv self.internal/capture value)))
#+end_src

*** Sudo

#+begin_src hy
#@(property (defn m/sudo [self] (return self.internal/sudo)))
#@(m/sudo.setter (defn m/sudo [self value]
                       (setv error-message
                             #[[Sorry! `m/sudo' must be a string of "i" or "s", or a dict-like object of length 1, key "i" or "s", and value `user', or a boolean!]]
                             self.internal/sudo (if value
                                                    (if (or (isinstance value bool) (= (len value) 1))
                                                        (cond [(isinstance value str)
                                                               (if (in value (, "i" "s"))
                                                                   { value "root" }
                                                                   (raise (ValueError error-message)))]
                                                              [(isinstance value bool) value]
                                                              [(isinstance value dict) (if (-> value (.keys) (iter) (next) (in (, "i" "s")))
                                                                                                                   value
                                                                                                                   (raise (ValueError error-message)))])
                                                        (raise (ValueError error-message)))
                                                    False))))
#+end_src

*** Environment Variables

#+begin_src hy
#@(property (defn m/exports [self] (return self.internal/exports)))
#@(m/exports.setter (defn m/exports [self value]
                          (setv self.internal/exports value)
                          (if value (setv self.m/intact-command (bool value)))))
#+end_src

**** New

#+begin_src hy
#@(property (defn m/new-exports [self] (return self.internal/new-exports)))
#@(m/new-exports.setter (defn m/new-exports [self value]
                              (setv self.internal/new-exports value)
                              (if value (setv self.m/intact-command (bool value)))))
#+end_src

** __init__

#+begin_src hy
(defn __init__ [
        self
        #* args
        [program- None]
        [base-program- None]
        [freezer- None]
        #** kwargs]
#+end_src

*** Append bakery to list of bakeries

Adapted from [[https://stackoverflow.com/users/100297/martijn-pieters][Martijn Pieters']] answer [[https://stackoverflow.com/a/26626707/10827766][here]], as well as [[https://stackoverflow.com/users/9567/torsten-marek][Torsten Marek's]] answer [[https://stackoverflow.com/a/328882/10827766][here]]:

#+begin_src hy
(.append self.__class__.m/stores (.ref weakref self self))
#+end_src

*** Type Groups

#+begin_src hy
(setv self.m/type-groups (D {}))
#+end_src

**** Acceptable Arguments

#+begin_src hy
(setv self.m/type-groups.acceptable-args [str int])
#+end_src

**** Reprs

#+begin_src hy
(setv self.m/type-groups.reprs (, "str" "repr"))
#+end_src

**** This Class and its Subclasses

#+begin_src hy
(setv self.m/type-groups.this-class-subclass [self.__class__])
(.extend self.m/type-groups.acceptable-args self.m/type-groups.this-class-subclass)
#+end_src

**** Genstrings

#+begin_src hy
(setv self.m/type-groups.genstrings [tea])
(.extend self.m/type-groups.acceptable-args self.m/type-groups.genstrings)
(setv self.m/type-groups.genstrings (tuple self.m/type-groups.genstrings))
#+end_src

**** Excluded classes

#+begin_src hy
(setv self.m/type-groups.excluded-classes (, "type" "filter"))
#+end_src

*** Subcommand

#+call: hash() :exports none

#+RESULTS:
: 20220111111603650875845

#+name: 20220111111603650875845
#+begin_src text
supercalifragilisticexpialidocious
#+end_src

Note that only via ~baking~ can subcommand-specific arguments and keyword arguments be set.

#+begin_src hy
(setv self.m/subcommand (D {})
      self.m/subcommand.default "<<20220111111603650875845>>"
      self.m/subcommand.current (D {})
      self.m/subcommand.current.unprocessed "<<20220111111603650875845>>"
      self.m/subcommand.current.intact False
      self.m/subcommand.current.processed "<<20220111111603650875845>>")
#+end_src

*** Arguments

#+begin_src hy
(setv self.m/args (D {})
      self.m/args.world []
      self.m/args.instantiated (list args)
      self.m/args.baked (D {})
      self.m/args.baked.<<20220111111603650875845>> []
      self.m/args.called []
      self.m/args.current (D {})
      self.m/args.current.unprocessed (D {})
      self.m/args.current.unprocessed.starter []
      self.m/args.current.unprocessed.regular []
      self.m/args.current.processed (D {})
      self.m/args.current.unprocessed.starter []
      self.m/args.current.unprocessed.regular [])
#+end_src

**** Keyword

#+begin_src hy
(setv self.m/kwargs (D {})
      self.m/kwargs.world (D {})
      self.m/kwargs.instantiated (D kwargs)
      self.m/kwargs.baked (D {})
      self.m/kwargs.baked.<<20220111111603650875845>> (D {})
      self.m/kwargs.called (D {})
      self.m/kwargs.current (D {})
      self.m/kwargs.current.unprocessed (D {})
      self.m/kwargs.current.unprocessed.starter (D {})
      self.m/kwargs.current.unprocessed.regular (D {})
      self.m/kwargs.current.processed (D {})
      self.m/kwargs.current.processed.starter []
      self.m/kwargs.current.processed.regular []
      self.m/kwargs.current.processed.starter-values []
      self.m/kwargs.current.processed.regular-values [])
#+end_src

*** Freezer

#+begin_src hy
(setv self.internal/freezer (.cls/freezer self.__class__ freezer- []))
#+end_src

*** Program

#+begin_src hy
(if program-
    (do (setv self.m/program (or (.replace (unmangle program-) "_" "-") ""))
        (if (in "--" self.m/program)
            (setv self.m/program (.join osPath (getcwd) (.replace self.m/program "--" "."))))
        (unless (check self self.m/program)
                (raise (ImportError f"cannot import name '{self.m/program}' from '{self.__class__.__module__}'")))
        (setv self.m/base-program (or base-program- self.m/program)))
    (setv self.m/program ""
          self.m/base-program (or base-program- self.m/program)))
#+end_src

*** Return Categories

#+begin_src hy
(setv self.m/return-categories (,
    "stdout"
    "stderr"
    "return-codes"
    "command"
    "tea"
    "verbosity"
))
#+end_src

*** Command

#+begin_src hy
(setv self.m/command (tea))
#+end_src

*** Shortcut Keywords
**** Run

Set ~m/capture~ to ~run~, for interactive output without capturing the stream:

#+begin_src hy :tangle no
(setv self.m/run False)
#+end_src

**** Context Manager

Set ~m/context~ to ~True~:

#+begin_src hy :tangle no
(setv self.m/c True)
#+end_src

*** Gitea

Set ~m/gitea.bool~ to ~True~, or add the program to ~m/gitea.list~ to allow this program to do something like ~git(C = path).status()~,
and set ~m/gitea.off~ to override and disable both.

Named after [[https://gitea.io/en-us/][gitea]] and my own [[https://gitlab.com/picotech/nanotech/gensing][gensing]] modules:

#+begin_src hy
(setv self.m/gitea (D {})
      self.m/gitea.list [ "git" "yadm" ]
      self.m/gitea.bool (or (in self.m/base-program self.m/gitea.list) False)
      self.m/gitea.off False)
#+end_src

*** Settings

#+begin_src hy
(setv self.m/settings (D {})
      self.m/settings.defaults (D {})
      self.m/settings.current (D {}))
#+end_src

#+name: m/
#+begin_src emacs-lisp :var setting="" :var value=""
(format-spec "(setv self.m/%s %v)
(setv self.m/settings.defaults.m/%s (deepcopy self.m/%s))"
`((?s . ,setting) (?v . ,value)))
#+end_src

#+name: internal/
#+begin_src emacs-lisp :var setting="" :var value=""
(format-spec "(setv self.internal/%s %v)
(setv self.m/settings.defaults.m/%s (deepcopy self.internal/%s))"
`((?s . ,setting) (?v . ,value)))
#+end_src

**** Intact Command

Don't lexically split and join the command to prevent shell-injection attacks:

#+begin_src hy
<<m/(setting="intact-command", value="(bool self.m/freezer)")>>
#+end_src

**** Programs

Default settings for certain programs and their subcommands:

#+begin_src hy
(setv self.m/settings.programs (D {})
      self.m/current-settings (D {})
      self.m/current-settings.program (D {})
      self.m/current-settings.subcommand (D {}))
#+end_src

***** Zpool

#+begin_src hy
(setv self.m/settings.programs.zpool (D {}))
#+end_src

****** Import

#+begin_src hy
(setv self.m/settings.programs.zpool.import (D { "m/sudo" True }))
#+end_src

***** ZFS

#+begin_src hy
(setv self.m/settings.programs.zfs (D {}))
#+end_src

****** Load Key

#+begin_src hy
(setv self.m/settings.programs.zfs.load-key (D { "m/run" True
                                                 "m/sudo" True }))
#+end_src

***** Rich

#+begin_src hy
(setv self.m/settings.programs.rich (D {}))
#+end_src

****** Default Subcommand

#+begin_src hy
(setv self.m/settings.programs.rich.<<20220111111603650875845>>.m/run True)
#+end_src

**** Environment Variables

Environment variables to be set while running the command,
passed in as dictionary of variable names and values:

#+begin_src hy
<<internal/(setting="exports", value="(D {})")>>
#+end_src

***** New Environment Variables

Environment variables to be set while running the command,

/COMPLETELY REPLACING THE OLD ENVIRONMENT,/

passed in as dictionary of variable names and values:

#+begin_src hy
<<internal/(setting="new-exports", value="(D {})")>>
#+end_src

**** Frozen Program

Return the bakery just before running the command; any type not in ~m/type-groups.acceptable-args~ will freeze the bakery:

#+begin_src hy
<<m/(setting="frozen", value="False")>>
#+end_src

**** Capture Type

Which output stream to capture; values are listed below in ~m/captures~:

#+begin_src hy
(setv self.m/captures (, "stdout" "stderr" "both" "run"))
<<internal/(setting="capture", value="\"stdout\"")>>
#+end_src

**** Shell

What shell to use:

#+begin_src hy
<<m/(setting="shell", value="None")>>
#+end_src

**** Pretty Prining

Pretty print the output:

#+begin_src hy
<<m/(setting="dazzle", value="False")>>
#+end_src

**** Ignore Output
***** Stdout

Ignore standard output:

#+begin_src hy
<<m/(setting="ignore-stdout", value="False")>>
#+end_src

***** Stderr

Ignore standard error:

#+begin_src hy
<<m/(setting="ignore-stderr", value="False")>>
#+end_src

**** Pipe STDERR to STDOUT

#+begin_src hy
<<m/(setting="stdout-stderr", value="False")>>
#+end_src

**** Verbosity

How verbose the output should be:

#+begin_src hy
<<m/(setting="verbosity", value=0)>>
#+end_src

**** Run As

Run bakery as program; useful when ~m/program~ is a path to a script:

#+begin_src hy
<<m/(setting="run-as", value="\"\"")>>
#+end_src

**** Number of Lines

How many lines of output to return; can chop ~n~ lines off the top or bottom.

Can accept a singular value of a boolean, string, or integer, a tuple of the same types,
or a dictionary of ~{ "last" [bool] "number" [int] "std" [string of "stdout", "stderr", or "both"] }~:

#+begin_src hy
<<internal/(setting="n-lines", value="(D { \"last\" \"False\" \"number\" 0 \"std\" \"stdout\" })")>>
#+end_src

**** Sort

Sort the output before it's converted, or if a list, return the sorted list; accepts a value of ~None~ for default sorting:

#+begin_src hy
<<internal/(setting="sort", value="False")>>
#+end_src

**** Filter

Filter the output before it's converted:

#+begin_src hy
<<internal/(setting="filter", value="False")>>
#+end_src

**** One Dash

Whether to use one dash for program options, such as in the case of ~find~:

#+begin_src hy
<<m/(setting="one-dash", value="False")>>
#+end_src

**** Fixed

Whether to keep underscores in program options instead of replacing them with dashes:

#+begin_src hy
<<m/(setting="fixed", value="False")>>
#+end_src

**** Intact Option

Whether to keep options as they are, not replacing underscores with dashes:

#+begin_src hy
<<m/(setting="intact-option", value="False")>>
#+end_src

**** Tiered

To use the ~m/tiered~ setting, bake the command in from before with all applicable
replacements replaced with ~{{ b.t }}~, and bake in ~m/tiered~ to True; then when
calling the command, pass in all the arguments that are going to replace the
~{{ b.t }}~ previously baked into the command.

To reset the command function, use the ~splat-~ function as necessary.

#+begin_src hy
<<m/(setting="tiered", value="False")>>
#+end_src

**** Input

Used to pass input to the ~subprocess Popen~ class; note that ~m/popen.stdin~ overrides this.

#+begin_src hy
<<m/(setting="input", value="None")>>
#+end_src

**** Regular Args

An alternate way to pass arguments to the program as a separate list:

#+begin_src hy
<<m/(setting="regular-args", value="(,)")>>
#+end_src

**** Regular Kwargs

An alternate way to pass options to the program as a separate dictionary:

#+begin_src hy
<<m/(setting="regular-kwargs", value="(D {})")>>
#+end_src

**** Context Manager

Whether the bakery is being used with a context manager:

#+begin_src hy
<<m/(setting="context", value="False")>>
#+end_src

**** Return Command

Return the command itself instead of the output of the command.

A good way to debug commands is to see what the command actually was
use the ~m/return-command~ keyword argument to return the final command.

#+begin_src hy
<<internal/(setting="return-command", value="False")>>
#+end_src

**** Print Command

Print the returned command from the setting above.

A good way to debug commands is to see what the command actually was
use the ~m/print-command~ keyword argument to print the final command.

#+begin_src hy
<<internal/(setting="print-command", value="False")>>
#+end_src

**** Print Command and Run

Print the command and continue running.

A good way to debug commands is to see what the command actually was
use the ~m/print-command-and-run~ keyword argument to print the final command and continue running.

#+begin_src hy
<<m/(setting="print-command-and-run", value="False")>>
#+end_src

**** Type of Output

~m/type~ can be any available type, such as:
- iter
- list
- tuple
- set
- frozenset

#+begin_src hy
<<m/(setting="type", value="iter")>>
#+end_src

**** Progress Bar

If the final output is an iterable, return it wrapped in an [[https://rich.readthedocs.io/en/stable/reference/progress.html][rich]] progress bar;
accepts a color string value:

#+begin_src hy
<<m/(setting="progress", value="None")>>
#+end_src

**** Split Output By Whitespace

Split the output by newlines, tabs, spaces, etc.

#+begin_src hy
<<m/(setting="split", value="False")>>
#+end_src

**** Use Single Forward Slash Instead of Dash

Use a single forward slash instead of a dash for options, as ~DOS~ expects:

#+begin_src hy
<<m/(setting="dos", value="False")>>
#+end_src

**** Wait

- If set to True, ~m/capture = "run"~ will wait for the process to finish before returning an addict dictionary of values depending on ~m/return~ and ~m/verbosity~
- If set to False, ~m/capture = "run"~ will return the ~Popen~ object
- If set to None, ~m/capture = "run"~ will wait for the process to finish before returning None

#+begin_src hy
<<m/(setting="wait", value="True")>>
#+end_src

**** Popen

A dictionary used to pass options to the ~subprocess Popen~ class:

#+begin_src hy
<<m/(setting="popen", value="(D {})")>>
#+end_src

**** Sudo

May be a string of length 1, and value ~i~ or ~s~, or a boolean.

If a dict-like object, must be in the form {"i" : user} or {"s" : user},
to use or not use the configuration files of the specified user.

#+begin_src hy
<<internal/(setting="sudo", value="False")>>
#+end_src

**** Debug

Print all the current values after each step; accepts a boolean or a dictionary of options passed to [[https://rich.readthedocs.io/en/latest/reference/init.html#rich.inspect][rich inspect]]:

#+begin_src hy
<<m/(setting="debug", value="False")>>
<<m/(setting="default-inspect-kwargs", value="(D { \"all\" True })")>>
#+end_src

*** End of Init

#+begin_src hy
)
#+end_src

** Miscellaneous
*** Type Name is String

#+begin_src hy
(defn misc/type-name-is-string [self [type/type None]]
      (return (in (. (or type/type self.m/type) __name__) self.m/type-groups.reprs)))
#+end_src

*** Reset All

#+begin_src hy
(defn m/reset-all [self]
      (.reset- self)
      (.command/reset self))
#+end_src

** Convert Type

#+begin_src hy
(defn m/convert-type [self input [type/type None]]
      (setv type/type/type (or type/type self.m/type))
      (if input
          (do (if (isinstance input self.m/type-groups.genstrings)
                  (let [frosted-input (input)]
                       (cond [(isinstance frosted-input str)
                              (setv input [(.fill (TextWrapper :break-long-words False :break-on-hyphens False) frosted-input)])]
                             [(isinstance frosted-input int) (if (.misc/type-name-is-string self :type/type type/type/type)
                                                                 (return (pretty-repr frosted-input))
                                                                 (return frosted-input))])))
              (if self.m/filter
                  (do (setv string-like (isinstance input str)
                            input (if self.m/filter.reverse
                                      (tuple (filterfalse self.m/filter.key input))
                                      (tuple (filter self.m/filter.key input))))
                      (if string-like (setv input (.join "" input)))))
              (if self.m/sort
                  (do (setv string-like (isinstance input str)
                            input (sorted input #** self.m/sort))
                      (if string-like (setv input (.join "" input)))))
              (return (cond [(and self.m/progress (coll? input)) (eclair input (.m/command self) self.m/progress)]
                            [(.misc/type-name-is-string self :type/type type/type/type) (.join "\n" input)]
                            [True (if (and self.m/sort (either? type/type/type list))
                                      input
                                      (type/type/type input))])))
          (return (type/type/type input))))
#+end_src

** Subcommand
*** Get

#+begin_src hy
(defn subcommand/get [self #** kwargs]
      (setv self.m/subcommand.current.intact (.cls/get-attr self.__class__ kwargs "m/intact-subcommand"))
      (setv subcommand (.cls/get-attr self.__class__ kwargs "m/subcommand" :default self.m/subcommand.default))
      (if (!= subcommand self.m/subcommand.default)
          (setv self.m/subcommand.current.unprocessed subcommand)))
#+end_src

*** Process

#+begin_src hy
(defn subcommand/process [self]
    (setv self.m/subcommand.current.processed (if self.m/subcommand.current.intact
                                                  self.m/subcommand.current.unprocessed
                                                  (.replace (unmangle self.m/subcommand.current.unprocessed) "_" "-"))))
#+end_src

** Variables
*** Set Defaults

#+begin_src hy
(defn var/set-defaults [self]
      (for [[key value] (.items self.m/settings.defaults)]
           (setattr self key (deepcopy value)))
      (setv self.m/current-settings.program (get-un-mangled self.m/settings.programs
                                                            self.m/base-program
                                                            :default (D {})))
      (for [[key value] (.items self.m/current-settings.program.<<20220111111603650875845>>)]
           (setattr self key (deepcopy value))))
#+end_src

*** Setup

#+begin_src hy
(defn var/setup [self #* args [subcommand- "<<20220111111603650875845>>"] #** kwargs]
      (.var/set-defaults self)

      (setv self.m/args.world (or (. (.origin- self) m/args world) []))
      (setv self.m/kwargs.world (or (. (.origin- self) m/kwargs world) (D {})))

      (if (= subcommand- self.m/subcommand.default)
          (do (.subcommand/get self #** self.m/kwargs.world)
              (.subcommand/get self #** self.m/kwargs.instantiated)
              (.subcommand/get self #** (. self m/kwargs baked [subcommand-]))
              (.subcommand/get self #** kwargs))
          (setv self.m/subcommand.current.unprocessed subcommand-))
      (unless self.m/subcommand.current.unprocessed
              (setv self.m/subcommand.current.unprocessed self.m/subcommand.default))
      (.subcommand/process self)

      (setv self.m/current-settings.subcommand (get-un-mangled self.m/current-settings.program
                                                               self.m/subcommand.current.processed
                                                               :default (D {})))
      (for [[key value] (.items self.m/current-settings.subcommand)]
           (setattr self key (deepcopy value)))

      (setv self.m/args.called args)
      (setv self.m/kwargs.called kwargs)

      (.var/process-all self #* args #** kwargs)

      (.var/apply self))
#+end_src

*** Reset

Note that ~subcommand~ is only really needed here to help reset the baked arguments and keyword arguments.

#+begin_src hy
(defn reset- [
            self
            [world False]
            [instantiated False]
            [baked False]
            [args False]
            [kwargs False]
            [all-subs False]
            [subcommand "<<20220111111603650875845>>"]
            [set-defaults True]]
      (setv self.m/current-settings (D {}))
      (for [m (, "settings" "subcommand" "args" "kwargs")]
           (assoc (getattr self (mangle (+ "m/" m))) "current" (D {})))
      (setv self.m/args.called [])
            self.m/kwargs.called (D {})
      (if world
          (for [store (.chain- self)]
               (if args (setv store.m/args.world []))
               (if kwargs (setv store.m/kwargs.world (D {})))))
      (if instantiated
          (do (if args (setv self.m/args.instantiated []))
              (if kwargs (setv self.m/args.instantiated (D {})))))
      (if baked
          (do (if args
                  (if all-subs
                      (do (setv self.m/args.baked (D {}))
                          (assoc self.m/args.baked self.m/subcommand.default []))
                          (assoc self.m/args.baked subcommand [])))
              (if kwargs
                  (if all-subs
                      (do (setv self.m/kwargs.baked (D {}))
                          (assoc self.m/kwargs.baked self.m/subcommand.default (D {})))
                          (assoc self.m/kwargs.baked subcommand (D {}))))))
      (if set-defaults (.var/set-defaults self)))
#+end_src

*** Process

#+begin_src hy
(defn var/process-all [self #* args #** kwargs]
      (.var/process-args self #* self.m/args.world)
      (.var/process-args self #* self.m/args.instantiated)
      (.var/process-args self #* (. self m/args baked [self.m/subcommand.current.unprocessed]))
      (.var/process-args self #* args)

      (.var/process-kwargs self #** self.m/kwargs.world)
      (.var/process-kwargs self #** self.m/kwargs.instantiated)
      (.var/process-kwargs self #** (. self m/kwargs baked [self.m/subcommand.current.unprocessed]))
      (.var/process-kwargs self #** kwargs))
#+end_src

**** Arguments

#+begin_src hy
(defn var/process-args [self #* args [starter False]]
      (for [arg args]
           (if (isinstance arg (tuple self.m/type-groups.acceptable-args))
               (if (isinstance (. self m/args current unprocessed [(if starter "starter" "regular")]) list)
                   (.append (. self m/args current unprocessed [(if starter "starter" "regular")]) arg)
                   (assoc self.m/args.current.unprocessed (if starter "starter" "regular") [arg]))
               (setv self.m/settings.current.m/frozen True))))
#+end_src

**** Keyword Arguments

#+begin_src hy
(defn var/process-kwargs [self #** kwargs]
      (defn inner [itr [starter False]]
            (for [[key value] (.items itr)]
                 (if (setx var/process/key-prefix (.cls/is-attr self.__class__ key))
                     (let [var/process/key (.cls/process-attr self.__class__ key var/process/key-prefix)]
                          (cond [(= var/process/key "m/starter-args")
                                 (.var/process-args self #* (if (isinstance value str) (, value) value) :starter True)]
                                [(= var/process/key "m/starter-kwargs") (inner value :starter True)]
#+end_src

The values in ~m/regular-args~ will always be appended to ~self.m/args.current.regular~,
since ~m/regular-args~ is a keyword argument.

#+begin_src hy
                                [(= var/process/key "m/regular-args") (.var/process-args self #* value)]
#+end_src

Note that, depending on where ~m/regular-kwargs~ is in the keyword arguments of the function call,
its values will replace any prexisting values of the same type; for example, in the following case,
where ~m/frozen~ is True, while ~m/regular-kwargs.frozen~ is False:
- If ~m/regular-kwargs~ is before ~m/frozen~, the value of ~m/frozen~ will replace the value of ~m/regular-kwargs.frozen~, and final value of ~m/frozen~ will be True
- If ~m/regular-kwargs~ is after ~m/frozen~, the value of ~m/regular-kwargs.frozen~ will replace the value of ~m/frozen~, and final value of ~m/frozen~ will be False
In other words, the values of whichever comes first will be replaced by the value of whichever comes second.

#+begin_src hy
                                [(= var/process/key "m/regular-kwargs") (inner value)]
#+end_src

Adapted from [[https://stackoverflow.com/users/2988730/mad-physicist][Mad Physicist's]] answer [[https://stackoverflow.com/a/70794425/10827766][here]]:

#+begin_src hy
                                [(let [trimmed-attr (-> self.__class__ (.cls/trim-attr-prefix var/process/key) (get 1))]
                                      (and (not (in trimmed-attr self.m/type-groups.excluded-classes))
                                           (class? (setx literal-attr (.get (globals) trimmed-attr (getattr builtins trimmed-attr None))))
                                           value))
                                 (setv self.m/settings.current.m/type literal-attr)]
#+end_src

#+begin_src hy
                                [True (unless (in var/process/key (, "m/subcommand"))
                                              (assoc self.m/settings.current key value))]))
                     (assoc (. self m/kwargs current unprocessed [(if starter "starter" "regular")]) key value))))
      (inner kwargs))
#+end_src

*** Apply

#+begin_src hy
(defn var/apply [self]
    (for [[key value] (.items self.m/settings.current)]
         (setattr self key value)))
#+end_src

** Command

The general command string will end up like this:

#+begin_src hy :tangle no
f"{m/shell} -c (or {m/freezer} {m/program})
               {m/kwargs.current.processed.starter}
               {m/subcommand.current.processed}
               {m/args.current.processed.starter}
               {m/kwargs.current.processed.regular}
               {m/args.current.processed.regular}"
#+end_src

*** Reset

#+begin_src hy
(defn command/reset [self] (unless self.m/frozen (setv self.m/command (tea))))
#+end_src

*** Process

#+begin_src hy
(defn command/process-all [self]
      (for [i (range 2)]
           (.command/process-args self :starter i)
           (.command/process-kwargs self :starter i)))
#+end_src

**** Arguments

#+begin_src hy
(defn command/process-args [self [starter False]]
      (for [arg (. self m/args current unprocessed [(if starter "starter" "regular")])]
           (setv command/process-args/arg (cond [(isinstance arg self.m/type-groups.genstrings) (arg)]
                                                [(isinstance arg int) (str arg)]
                                                [(isinstance arg self.__class__) (arg :m/type str)]
                                                [True arg]))
           (if (isinstance (. self m/args current processed [(if starter "starter" "regular")]) list)
               (.append (. self m/args current processed [(if starter "starter" "regular")]) command/process-args/arg)
               (assoc self.m/args.current.processed (if starter "starter" "regular") [command/process-args/arg]))))
#+end_src

**** Keyword Arguments

If the boolean value is non-truthy, don't put the argument in;
for example, if "program.subcommand([...], option = False)", then the result would be "program subcommand [...]",
i.e. without "--option".

#+begin_src hy
(defn command/process-kwargs [self [starter False]]
      (defn inner [value]
            (setv new-value (cond [(isinstance value self.m/type-groups.genstrings) (value)]
#+end_src

Again, remember that since ~bool~ is a subclass of ~int~, we need to first check if ~value~ is an instance of ~bool~, then ~int~,
otherwise ~(isinstance value int)~ will catch both cases.

#+begin_src hy
                                  [(isinstance value bool) None]
                                  [(isinstance value int) (str value)]
#+end_src

#+begin_src hy
                                  [(isinstance value self.__class__) (value :m/type str)]
                                  [True value]))
            (return new-value))
      (for [[key value] (.items (. self m/kwargs current unprocessed [(if starter "starter" "regular")]))]
           (if value
               (let [aa (tuple (+ self.m/type-groups.acceptable-args [dict bool]))]
                    (if (isinstance value aa)
                        (if (isinstance value dict)
                            (let [no-value-options ["repeat" "repeat-with-values" "rwv"]
                                  options (+ no-value-options ["fixed" "dos" "one-dash" "value"])
                                  dct-value (.get value "value" None)]
                                 (cond [dct-value (setv command/process-kwargs/value (inner dct-value))]
                                       [(any (gfor o (.keys value) (in o no-value-options))) (setv command/process-kwargs/value None)]
                                       [True (raise (AttributeError #[f[Sorry! You must use the "value" keyword if you do not use any of the following: {(.join ", " no-value-options)}]f]))])
                                 (for [[k v] (.items value)]
                                       (if (in k options)
                                           (if v
                                               (setv command/process-kwargs/key (if (or (= k "fixed")
                                                                                        self.m/fixed)
                                                                                    key
                                                                                    (.replace (unmangle key) "_" "-"))
                                                     command/process-kwargs/key (cond [(or (= k "dos")
                                                                                           self.m/dos)
                                                                                       (+ "/" command/process-kwargs/key)]
                                                                                      [(or (= k "one-dash")
                                                                                           self.m/one-dash
                                                                                           (= (len command/process-kwargs/key) 1))
                                                                                       (+ "-" command/process-kwargs/key)]
                                                                                      [True (+ "--" command/process-kwargs/key)])
                                                     command/process-kwargs/key-values (cond [(= k "repeat") (lfor i (range v) command/process-kwargs/key)]
                                                                                             [(in k (, "repeat-with-values" "rwv"))
                                                                                              (do (setv key-values [])
                                                                                                  (for [j v]
                                                                                                       (.append key-values command/process-kwargs/key)
                                                                                                       (if (setx l (inner j))
                                                                                                           (do (if (isinstance (. self
                                                                                                                                  m/kwargs
                                                                                                                                  current
                                                                                                                                  processed
                                                                                                                                  [(if starter
                                                                                                                                       "starter-values"
                                                                                                                                       "regular-values")]) list)
                                                                                                                   (.append (. self
                                                                                                                               m/kwargs
                                                                                                                               current
                                                                                                                               processed
                                                                                                                               [(if starter
                                                                                                                                    "starter-values"
                                                                                                                                    "regular-values")]) l)
                                                                                                                   (assoc self.m/kwargs.current.processed
                                                                                                                          (if starter
                                                                                                                              "starter-values"
                                                                                                                              "regular-values") [l]))
                                                                                                               (.append key-values l))))
                                                                                                  key-values)]
                                                                                             [True None]))
                                               (setv command/process-kwargs/key None
                                                     command/process-kwargs/value None
                                                     command/process-kwargs/key-values None))
                                           (raise (AttributeError #[f[Sorry! A keyword argument value of type dict can only have the following keys: {(.join ", " options)}]f])))))
                              [True (setv command/process-kwargs/value (inner value)
                                          command/process-kwargs/key (if self.m/fixed key (.replace (unmangle key) "_" "-"))
                                          command/process-kwargs/key (cond [self.m/dos (+ "/" command/process-kwargs/key)]
                                                                           [(or self.m/one-dash
                                                                                (= (len command/process-kwargs/key) 1))
                                                                            (+ "-" command/process-kwargs/key)]
                                                                           [True (+ "--" command/process-kwargs/key)])
                                          command/process-kwargs/key-values None)])
                        (raise (TypeError #[f[Sorry! Keyword argument value "{value}" of type "{(type value)}" must be one of the following types: {(.join ", " (gfor arg aa arg.__name__))}]f])))
           (if (or command/process-kwargs/key-values
                   command/process-kwargs/key)
               (do (if (isinstance (. self m/kwargs current processed [(if starter "starter" "regular")]) list)
                       (if command/process-kwargs/key-values
                           (.extend (. self m/kwargs current processed [(if starter "starter" "regular")]) command/process-kwargs/key-values)
                           (.append (. self m/kwargs current processed [(if starter "starter" "regular")]) command/process-kwargs/key))
                       (if command/process-kwargs/key-values
                           (assoc self.m/kwargs.current.processed (if starter "starter" "regular") command/process-kwargs/key-values)
                           (assoc self.m/kwargs.current.processed (if starter "starter" "regular") [command/process-kwargs/key])))))
           (if (and command/process-kwargs/value
                    (not command/process-kwargs/key-values))
               (do (if (isinstance (. self
                                      m/kwargs
                                      current
                                      processed
                                      [(if starter
                                           "starter-values"
                                           "regular-values")]) list)
                       (.append (. self
                                   m/kwargs
                                   current
                                   processed
                                   [(if starter
                                        "starter-values"
                                        "regular-values")]) command/process-kwargs/value)
                       (assoc self.m/kwargs.current.processed
                             (if starter
                                 "starter-values"
                                 "regular-values") [command/process-kwargs/value]))
                   (if (isinstance (. self
                                      m/kwargs
                                      current
                                      processed
                                      [(if starter
                                           "starter"
                                           "regular")]) list)
                       (.append (. self
                                   m/kwargs
                                   current
                                   processed
                                   [(if starter
                                        "starter"
                                        "regular")]) command/process-kwargs/value)
                       (assoc self.m/kwargs.current.processed
                             (if starter
                                 "starter"
                                 "regular") [command/process-kwargs/value]))))))))
#+end_src

*** Create Command

#+begin_src hy
(defn command/create [self]
      (if self.m/sudo
          (if (isinstance self.m/sudo bool)
              (.append self.m/command "sudo")
              (.append self.m/command f"sudo -{(-> self.m/sudo (.keys) (iter) (next))} -u {(-> self.m/sudo (.values) (iter) (next))}")))

      (if (and self.m/shell (not self.m/freezer))
          (do (.extend self.m/command self.m/shell "-c" "'")
              (if self.m/run-as
                  (do (.glue self.m/command self.m/run-as)
                      (.append self.m/command self.m/program))
                  (.glue self.m/command self.m/program)))
          (if self.m/run-as
              (.extend self.m/command self.m/run-as self.m/program)
              (.append self.m/command self.m/program)))

      (if self.m/freezer
          (do (if self.m/shell
                  (for [[index value] (enumerate self.m/freezer)]
                       (if (= (get value -1) "'")
                           (assoc self.m/freezer index (cut value 0 -1)))))
              (.extend self.m/command #* self.m/freezer)))

      (.extend self.m/command #* self.m/kwargs.current.processed.starter)
      (if (!= self.m/subcommand.default self.m/subcommand.current.unprocessed)
          (.append self.m/command self.m/subcommand.current.processed))
      (.extend self.m/command
               #* self.m/args.current.processed.starter
               #* self.m/kwargs.current.processed.regular
               #* self.m/args.current.processed.regular)
      (if self.m/shell
          (.glue self.m/command "'"))
      (if self.m/tiered
          (let [tier "{{ b.t }}"
                replacements (+ self.m/kwargs.current.processed.starter-values
                                self.m/args.current.processed.starter
                                self.m/kwargs.current.processed.regular-values
                                self.m/args.current.processed.regular)
                to-be-replaced (.count (.values self.m/command) tier)]
               (if (= to-be-replaced (len replacements))
                   (for [[index kv] (.items self.m/command :indexed True)]
                        (if (= kv.value tier)
                            (assoc self.m/command kv.key (get replacements index)))))
                   (raise (ValueError "Sorry! The number of tiered replacements must be equal to the number of arguments provided!")))))
#+end_src

** Output
*** Return

#+begin_src hy
(defn return/output [self]
      (cond [self.m/frozen (return (deepcopy self))]
            [self.m/return-command (return (.m/command self))]
            [True (let [output (.return/process self)]
                       (if (isinstance output dict)
                           (do (setv output.stderr (peekable output.stderr)
                                     stds (, "out" "err"))
                               (try (setv peek-value (.peek output.stderr))
                                    (except [StopIteration]
                                            (setv peek-value None)))
                               (unless (or (not peek-value)
                                           self.m/ignore-stderr
                                           self.m/stdout-stderr)
                                       (raise (SystemError (+ f"In trying to run `{(.m/command self)}':\n\n" (.join "\n" output.stderr)))))
                               (for [[std opp] (zip stds (py "stds[::-1]"))]
                                    (setv stdstd (+ "std" std)
                                          stdopp (+ "std" opp))
                                    (if (< self.m/verbosity 1)
                                        (if (= self.m/capture stdstd)
                                            (del (get output stdopp)))))))
                       (return output))]))
#+end_src

**** Process

#+begin_src hy
(defn return/process [self]
    (if (.m/command self)
        (do (setv process (.m/popen-partial self))
            (cond [(is self.m/wait None) (with [p (process :pp-stdout DEVNULL :pp-stderr DEVNULL)] (return None))]
                  [self.m/wait (with [p (process)]
                                     (setv return/process/return (D {}))
                                     (for [std (, "out" "err")]
                                          (setv chained []
                                                stdstd (+ "std" std))
                                          (if (setx output (getattr p stdstd))
                                              (for [line output] (setv chained (chain
                                                   chained
                                                   [(if (isinstance line (, bytes bytearray)) (.strip (.decode line "utf-8")) (.strip line))]))))
                                              (assoc return/process/return stdstd (iter chained)))
                                     (.wait p)
                                     (if (> self.m/verbosity 0)
                                         (setv return/process/return.returns.code p.returncode
                                               ;; return/process/return.returns.codes p.returncodes
                                               return/process/return.command.bakery (.m/command self)
                                               return/process/return.command.subprocess p.args
                                               return/process/return.pid p.pid))
                                     (if (> self.m/verbosity 1)
                                         (setv return/process/return.tea self.m/command
                                               return/process/return.subcommand self.m/subcommand))
                                     (let [first-last-n-part (partial first-last-n :last self.m/n-lines.last
                                                                                   :number self.m/n-lines.number)]
                                          (if (in self.m/n-lines.std (, "stdout" "both"))
                                              (setv return/process/return.stdout (first-last-n-part :iterable return/process/return.stdout)))
                                          (if (in self.m/n-lines.std (, "stderr" "both"))
                                              (setv return/process/return.stderr (first-last-n-part :iterable return/process/return.stderr))))
                                     (return return/process/return))]
                  [True (return (process))]))
        (return None)))
#+end_src

**** Frosting

#+begin_src hy
(defn return/frosting [self]
      (if (setx output (.return/output self))
          (do (if self.m/frozen (return output))
              (setv frosted-output (if (and (isinstance output dict)
                                            (= (len output) 1))
                                       (-> output (.values) (iter) (next))
                                       output)
                    dict-like-frosted-output (isinstance frosted-output dict)
                    frosted-output (if self.m/dazzle
                                       (cond [dict-like-frosted-output frosted-output]
                                             [(coll? frosted-output) (tuple frosted-output)]
                                             [True (, frosted-output)])
                                       frosted-output))
              (if self.m/print-command-and-run (print (.m/command self)))
              (cond [dict-like-frosted-output
                     (for [std (, "out" "err")]
                          (setv stdstd (+ "std" std))
                          (if (hasattr frosted-output stdstd)
                              (do (setv new-frosted-output (get frosted-output stdstd))
                                  (if self.m/split
                                      (setv new-frosted-output (split-and-flatten new-frosted-output)))
                                  (assoc frosted-output stdstd (.m/convert-type self new-frosted-output)))))]
                    [True (do (setv new-frosted-output (frosting frosted-output self.m/capture))
                              (if self.m/split
                                  (setv new-frosted-output (split-and-flatten new-frosted-output)))
                              (setv new-frosted-output (.m/convert-type self new-frosted-output)))])
              (cond [self.m/print-command (print new-frosted-output)]
                    [self.m/dazzle (if dict-like-frosted-output
                                       (for [cat new-frosted-output]
                                            (setv outcat (get output cat))
                                            (if (or (isinstance outcat int)
                                                    (isinstance outcat str))
                                                (print f"{cat}: {outcat}")
                                                (do (unless (in cat self.m/captures)
                                                            (print (+ cat ": ")))
                                                    (if (= cat "return-codes")
                                                        (print outcat)
                                                        (for [line outcat]
                                                             (print line))))))
                                       (for [line new-frosted-output]
                                            (print line)))])
              (return new-frosted-output))
          (return None)))
#+end_src

*** Popen Partial

#+begin_src hy
(defn m/popen-partial [self [stdout None] [stderr None]]
      (setv pp-stdout (cond [stdout]
                            [(= self.m/capture "stderr") (.get self.m/popen "stdout" DEVNULL)]
                            [(= self.m/capture "run") (.get self.m/popen "stdout" None)]
                            [True (if self.m/ignore-stdout
                                      (.get self.m/popen "stdout" DEVNULL)
                                      (.get self.m/popen "stdout" PIPE))])
            pp-stderr (or stderr (if (= self.m/capture "run")
                                     (.get self.m/popen "stderr" None)
                                     (cond [self.m/stdout-stderr (.get self.m/popen "stderr" STDOUT)]
                                           [self.m/ignore-stderr (.get self.m/popen "stderr" DEVNULL)]
                                           [True (.get self.m/popen "stderr" PIPE)])))
            bufsize (.get self.m/popen "bufsize" -1)
            universal-newlines (.get self.m/popen "universal-newlines" None)
            universal-text (if (= bufsize 1)
                               True
                               universal-newlines)
            shell (.get self.m/popen "shell" self.m/intact-command)
            command (.m/command self)
#+end_src

For some reason, ~Popen's env~ keyword doesn't like [[https://github.com/mewwts/addict][addicts]]:

#+begin_src hy
            env (or (dict self.m/new-exports) (.copy environ))
#+end_src

#+begin_src hy
            executable (.get self.m/popen "executable" None)
            kwargs { "bufsize" bufsize
                     "stdin" (.get self.m/popen "stdin" self.m/input)
                     "stdout" pp-stdout
                     "stderr" pp-stderr
                     "executable" executable
                     "universal_newlines" universal-text
                     "text" universal-text
                     "shell" shell })
      (.update env self.m/exports)
      (assoc kwargs "env" env)
      (.update kwargs self.m/popen)
      (return (partial Popen
                       (if self.m/intact-command
                           command
                           (if shell
                               (join (split command))
                               (split command)))
                       #** kwargs)))
#+end_src

** Run

#+begin_src hy
(defn m/spin [self #* args [subcommand- "<<20220111111603650875845>>"] #** kwargs]
      (defn inner [title]
            (setv opts (or self.m/debug (.cls/get-attr self.__class__ kwargs "m/debug" :default self.m/debug))
                  bool-opts {})
            (if (isinstance opts dict)
                (do (.update opts { "title" title })
                    (.inspect- self #** opts))
                (if opts
                    (do (.update bool-opts self.m/default-inspect-kwargs)
                        (.update bool-opts { "title" title })
                        (.inspect- self #** bool-opts)))))
      (try (inner "Setup")
           (.var/setup self #* args :subcommand- subcommand- #** kwargs)

           (inner "Process")
           (.command/process-all self)

           (inner "Create")
           (.command/create self)

           (inner "Return")
           (return (.return/frosting self))

           (finally (inner "Reset")
                    (.m/reset-all self))))
#+end_src

** Apply Pipe or Redirect

#+begin_src hy
(defn m/apply-pipe-redirect [self pr value]
    (setv is-milcery (isinstance value self.__class__))
    (defn inner [v]
          (let [type-string (.join ", " (gfor t (+ (list self.m/type-groups.genstrings)
                                                   self.m/type-groups.this-class-subclass
                                                   [str]) t.__name__))]
               (return (cond [(isinstance v self.m/type-groups.genstrings) [(v)]]
                             [is-milcery (or v.m/freezer (.values v.m/command) [v.m/base-program])]
                             [(isinstance v str) [v]]
                             [True (raise (NotImplemented f"Sorry! Value '{v}' can only be of the following types: {type-string}"))]))))
#+end_src

If the value is a tuple, assume the first item is the value itself, while the second item is the pr;
this allows for more compilcated redirects, such as ~&>~, ~2>&1~, etc.

#+begin_src hy
    (if (isinstance value tuple)
        (if (= (len value) 2)
            (setv processed-value (inner (first value))
                  processed-pr (get value 1))
            (raise (NotImplemented "Sorry! A tuple value may only contain 2 items: (value, pr)")))
        (setv processed-value (inner value)
              processed-pr pr))
#+end_src

#+begin_src hy
    (setv kwargs {}
#+end_src

Note that ~freezer-~ will always use the ~m/freezer~ value from the bakery on the left-hand side of the operation calling it:

#+begin_src hy
          freezer- (+ (or self.m/freezer (list (.values self.m/command)) [self.m/base-program]) [processed-pr processed-value]))
#+end_src

#+begin_src hy
    (.update kwargs (.cls/remove-if-not-attr self.__class__ self.m/kwargs.world))
    (if is-milcery (.update kwargs (.cls/remove-if-not-attr value.__class__ value.m/kwargs.world)))

    (.update kwargs (.cls/remove-if-not-attr self.__class__ self.m/kwargs.instantiated))
    (if is-milcery (.update kwargs (.cls/remove-if-not-attr value.__class__ value.m/kwargs.instantiated)))

    (.update kwargs
             (.cls/remove-if-not-attr self.__class__ (. self m/kwargs baked [(or self.m/subcommand.current.unprocessed self.m/subcommand.default)])))
    (if is-milcery
        (.update kwargs (.cls/remove-if-not-attr value.__class__ (. value
                                                                    m/kwargs
                                                                    baked
                                                                    [(or value.m/subcommand.current.unprocessed value.m/subcommand.default)]))))

    (.update kwargs (.cls/remove-if-not-attr self.__class__ self.m/kwargs.called))
    (if is-milcery (.update kwargs (.cls/remove-if-not-attr value.__class__ value.m/kwargs.called)))

    (return (.__class__ self :freezer- freezer-
                             :base-program- self.m/base-program
                             #** kwargs)))
#+end_src

** Funktions
*** Miscellaneous
**** Deepcopy With Arguments

#+begin_src hy
(defn deepcopy- [self #* args [subcommand- "<<20220111111603650875845>>"] #** kwargs]
      (setv cls (deepcopy self))
      (.bake- cls #* args :instantiated- True :m/subcommand subcommand- #** kwargs)
      (return cls))
#+end_src

**** Check Program

#+begin_src hy
(defn check- [self] (return (check self self.m/program)))
#+end_src

*** Freeze

#+begin_src hy
(defn freeze- [self] (setv self.m/frozen True))
#+end_src

**** Defrost

#+begin_src hy
(defn defrost- [self] (setv self.m/frozen self.m/settings.m/frozen))
#+end_src

*** Great [Insert Country Here] Bakeoff!

[["Bake"][https://amoffat.github.io/sh/sections/baking.html]] arguments and options into the command from before for specific subcommands:

#+begin_src hy
(defn bake- [self #* args [subcommand- "<<20220111111603650875845>>"] [instantiated- False] #** kwargs ]
      (.extend (if instantiated-
                   self.m/args.instantiated
                   (. self m/args baked [subcommand-])) args)
      (.update (if instantiated-
                   self.m/kwargs.instantiated
                   (. self m/kwargs baked [subcommand-])) kwargs))
#+end_src

**** Bake All

[["Bake"][https://amoffat.github.io/sh/sections/baking.html]] arguments and options into all bakeries:

#+begin_src hy
(defn bake-all- [self #* args #** kwargs ]
      (for [store (.chain- self)]
           (.extend store.m/args.world args)
           (.update store.m/kwargs.world kwargs)))
#+end_src

**** Unbake

Remove baked arguments and options; accepts keyword arguments taken by ~reset-~:

#+begin_src hy
(defn splat- [self [set-defaults False] #** kwargs] (.reset- self :baked True :set-defaults set-defaults))
#+end_src

**** Unbake All

Remove arguments and options from all bakeries; accepts keyword arguments taken by ~reset-~:

#+begin_src hy
(defn splat-all- [self [set-defaults False] #** kwargs]
      (for [store (.chain- self)]
           (.reset- self :set-defaults set-defaults #** kwargs)))
#+end_src

*** Current Values

Return an ~addict~ dictionary with all the current values for the class variables;
can be used for debugging purposes or otherwise.

#+begin_src hy
(defn current-values- [self]
      (setv sd (D { "__slots__" (recursive-unmangle (dfor var
                                                         self.__slots__
                                                         :if (!= var "__dict__")
                                                         [var (getattr self var)])) }))
      (if (hasattr self "__dict__")
          (setv sd.__dict__ self.__dict__))
      (return sd))
#+end_src

**** Print

Debug the current function:

#+begin_src hy
(defn inspect- [self #** kwargs] 
      (unless kwargs
              (setv kwargs self.m/default-inspect-kwargs))
      (inspect self :Hy True #** kwargs))
#+end_src

*** Bakeries
**** Original

Get the original bakery object:

#+begin_src hy
(defn origin- [self] (return (. (first self.__class__.m/stores) __callback__)))
#+end_src

**** All

Return a list of all bakeries:

#+begin_src hy
(defn chain- [self] (return (lfor store self.__class__.m/stores store.__callback__)))
#+end_src

** Magic Methods

Adapted from [[https://realpython.com/primer-on-python-decorators/][Primer on Python Decorators]]:

#+call: hash() :exports none

#+RESULTS:
: 20220101204858374153059

#+name: 20220101204858374153059
#+begin_src emacs-lisp :var subcommand='nil
(format-spec
"(cond [(or (.cls/get-attr self.__class__ kwargs \"m/context\" False)
           (.cls/get-attr self.__class__ kwargs \"m/c\" False))
       (return (.deepcopy- self #* args %s #** kwargs))]
      [True (return (.m/spin self #* args %s #** kwargs))])"
    `((?s . ,(if subcommand ":subcommand- subcommand" ""))))
#+end_src

*** __call__

#+begin_src hy
(defn __call__ [
        self
        #* args
        [args-before-func (,)]
        #** kwargs ]
    (if (and (not self.m/gitea.off)
             (or self.m/gitea.bool
                 (in self.m/base-program self.m/gitea.list)))
        (return (.deepcopy- self :m/starter-args args :m/starter-kwargs kwargs))
        <<20220101204858374153059()>>))
#+end_src

*** __setattr__

#+begin_src hy
(defn __setattr__ [self attr value] (.__setattr__ (super) (.cls/process-if-attr self.__class__ attr) value))
#+end_src

*** __getattr__

#+begin_src hy
(defn __getattr__ [self subcommand]
    (if (setx attr (.cls/process-if-attr self.__class__ subcommand :return-bool True))
        (getattr self __getattr__/attr (raise (AttributeError f"Sorry! `{(unmangle subcommand)}' doesn't exist as an attribute!")))
        (do (defn inner [
                    #* args
                    [args-before-func (,)]
                    #** kwargs ]
                  <<20220101204858374153059(subcommand='t)>>)
            (return inner))))
#+end_src

*** __copy__

Note that copies have ~m/frozen~ set to its default.

Adapted from [[https://gist.github.com/shadowrylander/a4d861fc37d381b8edc4b8e7793000d1][here]]:

#+begin_src hy
(defn __copy__ [self]
#+end_src

#+begin_quote
Create a new instance
#+end_quote

#+begin_src hy
    (setv cls self.__class__
          result (.__new__ cls cls)
#+end_src

#+begin_quote
Get all ~__slots__~ of the derived class
#+end_quote

#+begin_src hy
          slots (.from-iterable chain (lfor s self.__class__.__mro__ (getattr s "__slots__" []))))
#+end_src

#+begin_quote
Copy all attributes
#+end_quote

#+begin_src hy
    (for [var slots] (unless (in var (, "__weakref__"))
                             (setattr result var (copy (getattr self var)))))
    (if (hasattr self "__dict__")
        (.update result.__dict__ self.__dict__))
#+end_src

Reset ~m/frozen~:

#+begin_src hy
    (setv result.m/frozen result.m/settings.defaults.m/frozen)
#+end_src

#+begin_quote
Return updated instance
#+end_quote

#+begin_src hy
    (return result))
#+end_src

*** __deepcopy__

Note that deepcopies have ~m/frozen~ set to its default.

Adapted from [[https://gist.github.com/shadowrylander/a4d861fc37d381b8edc4b8e7793000d1][here]]:

#+begin_src hy
(defn __deepcopy__ [self memo]
#+end_src

#+begin_quote
Create a new instance
#+end_quote

#+begin_src hy
    (setv cls self.__class__
          result (.__new__ cls cls))
#+end_src

#+begin_quote
Don't copy self reference
#+end_quote

#+begin_src hy
    (assoc memo (id self) result)
#+end_src

#+begin_quote
Don't copy the cache - if it exists
#+end_quote

#+begin_src hy
    (if (and (hasattr self "m/cache") self.m/cache) (assoc memo (id self.m/cache) (.__new__ self.m/cache dict)))
#+end_src

#+begin_quote
Get all ~__slots__~ of the derived class
#+end_quote

#+begin_src hy
    (setv slots (.from-iterable chain (lfor s self.__class__.__mro__ (getattr s "__slots__" []))))
#+end_src

#+begin_quote
Deep copy all other attributes
#+end_quote

#+begin_src hy
    (for [var slots]
         (unless (in var (, "__weakref__"))
                 (setattr result var (deepcopy (getattr self var) memo))))
    (if (hasattr self "__dict__")
        (for [[k v] (.items self.__dict__)] (setattr result k (deepcopy v memo))))
#+end_src

Reset ~m/frozen~:

#+begin_src hy
    (setv result.m/frozen result.m/settings.defaults.m/frozen)
#+end_src

#+begin_quote
Return updated instance
#+end_quote

#+begin_src hy
    (return result))
#+end_src

*** __iter__

#+begin_src hy
(defn __iter__ [self] (yield-from (.m/spin self)))
#+end_src

*** __or__

#+begin_src hy
(defn __or__ [self value] (return (.m/apply-pipe-redirect self "|" value)))
#+end_src

*** __and__

#+begin_src hy
(defn __and__ [self value] (return (.m/apply-pipe-redirect self "| tee" value)))
#+end_src

*** __add__

#+begin_src hy
(defn __add__ [self value] (return (.m/apply-pipe-redirect self "| tee -a" value)))
#+end_src

*** __lt__

#+begin_src hy
(defn __lt__ [self value] (return (.m/apply-pipe-redirect self "<" value)))
#+end_src

*** __lshift__

#+begin_src hy
(defn __lshift__ [self value] (return (.m/apply-pipe-redirect self "<<" value)))
#+end_src

*** __gt__

#+begin_src hy
(defn __gt__ [self value] (return (.m/apply-pipe-redirect self ">" value)))
#+end_src

*** __rshift__

#+begin_src hy
(defn __rshift__ [self value] (return (.m/apply-pipe-redirect self ">>" value)))
#+end_src

*** __ror__

#+begin_src hy
(defn __or__ [self value] (return (.m/apply-pipe-redirect self "|" value)))
#+end_src

*** __rand__

#+begin_src hy
(defn __and__ [self value] (return (.m/apply-pipe-redirect self "| tee" value)))
#+end_src

*** __radd__

#+begin_src hy
(defn __add__ [self value] (return (.m/apply-pipe-redirect self "| tee -a" value)))
#+end_src

*** __rlt__

#+begin_src hy
(defn __lt__ [self value] (return (.m/apply-pipe-redirect self "<" value)))
#+end_src

*** __rlshift__

#+begin_src hy
(defn __lshift__ [self value] (return (.m/apply-pipe-redirect self "<<" value)))
#+end_src

*** __rgt__

#+begin_src hy
(defn __gt__ [self value] (return (.m/apply-pipe-redirect self ">" value)))
#+end_src

*** __rrshift__

#+begin_src hy
(defn __rshift__ [self value] (return (.m/apply-pipe-redirect self ">>" value)))
#+end_src

*** __enter__

#+begin_src hy
(defn __enter__ [self] (return (deepcopy self)))
#+end_src

*** __exit__

#+begin_src hy
(defn __exit__ [self exception-type exception-val exception-traceback] False)
#+end_src

** End of Milcery

#+begin_src hy
)
#+end_src
