#+setupfile: ../settings/README.org
#+include: ../settings/README.org
#+property: header-args:hy :tangle yes :comments both

Inspired by [[https://amoffat.github.io/sh/][sh]] by [[https://github.com/amoffat][Andrew Moffat]].

* Imports

#+begin_src hy
(import builtins)
(import pout weakref)
#+end_src

** From

#+begin_src hy
(import addict [Dict :as D])
(import ast [literal-eval])
(import autoslot [SlotsPlusDictMeta])
(import collections [OrderedDict])
(import copy [copy deepcopy])
(import functools [partial wraps])
(import gensing [frosting tea])
(import hy [mangle unmangle])
(import hyrule [coll?])
(import inspect [isclass :as class?])
(import itertools [chain tee])
(import nanite [fullpath peek trim])
(import os [environ])
(import rich [pretty print inspect])
(import rich.pretty [pretty-repr pprint])
(import shlex [join split])
(import subprocess [DEVNULL PIPE Popen])
(import textwrap [TextWrapper])
(import toml [load])
(import toolz [first])
(import types [MethodType])
(import typing [Any Dict Generator Tuple Union])
#+end_src

* Requires

#+begin_src hy
(require hyrule [-> ->> assoc])
#+end_src

* The Meta Class

Adapted from [[https://stackoverflow.com/a/1800999/10827766][this answer]] by [[https://stackoverflow.com/users/36433/a-coady][A. Coady]], as well as [[https://stackoverflow.com/a/31537249/10827766][this answer]] by [[https://stackoverflow.com/users/302343/timur][Timur]].

Remember that ~metaclasses~ use ~cls~ instead of ~self~!

#+begin_src hy
(defclass melcery [SlotsPlusDictMeta]
#+end_src

** __init__

#+begin_src hy
(defn __init__ [cls #* args #** kwargs] (setv cls.m/stores [])))
#+end_src

* The Milcery Class

#+begin_src hy
(defclass milcery [:metaclass melcery]
#+end_src

Adapted from [[the man himself][https://github.com/python/typing/issues/345#issuecomment-270814750]],
as well as from the [[https://github.com/cjrh/autoslot][autoslot]] documentation (by [[https://github.com/cjrh][Caleb Hattingh]]) [[https://github.com/cjrh/autoslot#weakref][here]]:

#+begin_src hy
(setv __slots__ [ "__weakref__" ])
#+end_src

** Class Methods
*** Flatten Iterable

# TODO: Add to nanite

#+begin_src hy
#@(classmethod (defn cls/flatten [cls iterable [times None]]
                     (setv lst [])
                     (for [i iterable]
                          (if (and (coll? i)
                                   (or (is times None)
                                       times))
                              (.extend lst (.cls/flatten cls i :times (if times (dec times) times)))
                              (.append lst i)))
                     (return lst)))
#+end_src

*** Split and Flatten

#+begin_src hy
#@(classmethod (defn cls/split-and-flatten [cls iterable] (.cls/flatten cls (gfor j (.cls/flatten cls iterable) (.split j)))))
#+end_src

*** Freezer

#+begin_src hy
#@(classmethod (defn cls/freezer [cls value freezer]
                      (cond [(not value) (setv freezer [])]
                            [(coll? value)
                             (do (if (not (isinstance freezer list)) (setv freezer []))
                                 (.extend freezer value)
                                 (setv freezer (.cls/flatten cls (gfor i freezer :if i i))))]
                            [True (raise (TypeError f"Sorry! The 'm/freezer' can only accept non-string iterables or non-truthy values!"))])
                      (return freezer)))
#+end_src

*** String Prefix

#+begin_src hy
#@(classmethod (defn cls/string-prefix [cls b a] (+ a b)))
#+end_src

*** Process Attribute

#+begin_src hy
#@(classmethod (defn cls/process-attr [cls attr prefix]
                     (setv attr (unmangle attr))
                     (if (.startswith attr prefix)
                         (.replace attr "_" "-")
                         (-> attr
                             (.lstrip "_")
                             (.cls/string-prefix cls prefix)
                             (.replace "_" "-")
                             (mangle)))))
#+end_src

*** Is Attribute

#+begin_src hy
#@(classmethod (defn cls/is-attr [cls attr]
                     (setv attr (unmangle attr))
                     (cond [(.endswith attr "__") (return "__")]
                           [(.startswith attr "__") (return "internal/")]
                           [(.startswith attr "_") (return "m/")]
                           [(.startswith attr "internal/") (return "internal/")]
                           [(.startswith attr "m/") (return "m/")]
                           [True (return False)])))
#+end_src

*** Process If Attribute

#+begin_src hy
#@(classmethod (defn cls/process-if-attr [cls attr [return-bool False]]
                     (setv attr (unmangle attr))
                     (return (if (setx prefix (.cls/is-attr cls attr))
                                 (mangle (.cls/process-attr cls attr prefix))
                                 (if return-bool False (mangle attr))))))
#+end_src

*** Remove If Not Attribute

#+begin_src hy
#@(classmethod (defn cls/remove-if-not-attr [cls dct] (return (dfor [key value] (.items dct) :if (.cls/is-attr cls key) [ key value ]))))
#+end_src

*** Trim Attribute Prefix

#+begin_src hy
#@(classmethod (defn cls/trim-attr-prefix [cls attr]
                     (setv attr (unmangle attr))
                     (let [prefix (.cls/is-attr cls attr)]
                          (return (, prefix (if prefix (mangle (.removeprefix attr prefix)) (mangle attr)))))))
#+end_src

*** Get Attribute

#+begin_src hy
#@(classmethod (defn cls/get-attr [cls dct attr [default False]]
                     (setv attr (unmangle attr))
                     (setv [prefix cls/get-attr/attr] (.cls/trim-attr-prefix cls attr))
                     (return (or (.get dct (mangle (+ "__" cls/get-attr/attr)) False)
                                 (.get dct (mangle (+ "_" cls/get-attr/attr)) False)
                                 (.get dct (mangle (+ "internal/" cls/get-attr/attr)) False)
                                 (.get dct (mangle (+ "m/" cls/get-attr/attr)) default)))))
#+end_src

** Properties
*** Freezer

This tells the bakery that the program is a combination of multiple programs, such as ~ls | tail~.

#+begin_src hy
#@(property (defn m/freezer [self] (return self.internal/freezer)))
#@(m/freezer.setter (defn m/freezer [self value] (setv self.internal/freezer (.cls/freezer self.__class__ value self.internal/freezer))))
#+end_src

*** Command
**** Return

Return the final command:

#+begin_src hy
#@(property (defn m/return-command [self] (return self.internal/return-command)))
#@(m/return-command.setter (defn m/return-command [self value]
                                 (setv self.internal/return-command (bool value))
                                 (if value (setv self.m/type str))))
#+end_src

**** Print

Print the final command:

#+begin_src hy
#@(property (defn m/print-command [self] (return self.internal/print-command)))
#@(m/print-command.setter (defn m/print-command [self value]
                                (setv self.internal/print-command (bool value))
                                (if value (setv self.m/return-command True))))
#+end_src

**** Run Interactively

#+begin_src hy
#@(property (defn m/run [self] (return (= self.m/capture "run"))))
#@(m/run.setter (defn m/run [self value] (if value (setv self.m/capture "run"))))
#+end_src

*** Output
**** Number of Lines

~ordinal~ will shave off the first or last ~n~ lines off of ~std~, whether that be ~stdout~ or ~stderr~:

#+begin_src hy
#@(property (defn m/n-lines [self] (return self.internal/n-lines)))
#@(m/n-lines.setter (defn m/n-lines [self value]

    (setv ordinal (.get value "ordinal" "first"))
    (if ordinal
        (if (not (in ordinal (setx ordinals (, "first" "last"))))
            (raise (TypeError #[f[Sorry! You must choose an `ordinal' value from: {(.join ", " ordinals)}]f])))
        (assoc value "ordinal" "first"))

    (setv number (.get value "number" 0))
    (if number
        (cond [(is number None) None]
              [(< (int number) 1) (raise (ValueError "Sorry! `n' must be greater than 0!"))])
        (assoc value "number" None))

    (setv std (.get value "std" "stdout"))
    (if std
        (if (not (in std (setx stds (, "stdout" "stderr" "both"))))
            (raise (TypeError #[f[Sorry! You must choose an `std' value from: {(.join ", " stds)}]f]))
        (assoc value "std" "stdout")))
    
    (setv self.internal/n-lines (D value))))
#+end_src

*** Context Manager

Use function as context manager:

#+begin_src hy
#@(property (defn m/c [self] (return self.m/context)))
#@(m/c.setter (defn m/c [self value] (setv self.m/context (bool value))))
#+end_src

*** Capture

Capture types, consisting of ~stdout~, ~stderr~, and both:

#+begin_src hy
#@(property (defn m/capture [self] (return self.internal/capture)))
#@(m/capture.setter (defn m/capture [self value]
                          (if (not (in value self.m/captures))
                              (raise (TypeError #[f[Sorry! Capture type "{value}" is not permitted! Choose from one of: {(.join ", " self.m/captures)}]f])))
                          (setv self.internal/capture value)))
#+end_src

*** Sudo

#+begin_src hy
#@(property (defn m/sudo [self] (return self.internal/sudo)))
#@(m/sudo.setter (defn m/sudo [self value]
                       (setv error-message
                             #[[Sorry! `m/sudo' must be a string of "i" or "s", a tea, frosting, or dict-like object of length 1, key "i" or "s", and value `user', or a boolean!]]
                             self.internal/sudo (if value
                                                    (if (or (isinstance value bool) (= (len value) 1))
                                                        (cond [(isinstance value str)
                                                               (if (in value (, "i" "s"))
                                                                   { value "root" }
                                                                   (raise (ValueError error-message)))]
                                                              [(isinstance value bool) value]
                                                              [(isinstance value self.m/type-groups.dict-like) (if (-> value (.keys) (iter) (next) (in (, "i" "s")))
                                                                                                                   value
                                                                                                                   (raise (ValueError error-message)))])
                                                        (raise (ValueError error-message)))
                                                    False))))
#+end_src

** __init__

#+begin_src hy
(defn __init__ [
        self
        #* args
        [program- None]
        [base-program- None]
        [freezer- None]
        #** kwargs]
#+end_src

*** Append bakery to list of bakeries

Adapted from [[https://stackoverflow.com/a/26626707/10827766][this answer]] by [[https://stackoverflow.com/users/100297/martijn-pieters][Martijn Pieters]], as well as [[https://stackoverflow.com/a/328882/10827766][this answer]] by [[https://stackoverflow.com/users/9567/torsten-marek][Torsten Marek]]:

#+begin_src hy
(.append self.__class__.m/stores (.ref weakref self self))
#+end_src

*** Type Groups

#+begin_src hy
(setv self.m/type-groups (D {}))
#+end_src

**** Acceptable Arguments

#+begin_src hy
(setv self.m/type-groups.acceptable-args [str int])
#+end_src

**** Reprs

#+begin_src hy
(setv self.m/type-groups.reprs (, "str" "repr"))
#+end_src

**** This Class and its Subclasses

#+begin_src hy
(setv self.m/type-groups.this-class-subclass [self.__class__])
(.extend self.m/type-groups.acceptable-args self.m/type-groups.this-class-subclass)
#+end_src

**** Dict-Like

#+begin_src hy
(setv self.m/type-groups.dict-like [dict])
#+end_src

**** Genstrings

#+begin_src hy
(setv self.m/type-groups.genstrings [tea frosting])
(.extend self.m/type-groups.acceptable-args self.m/type-groups.genstrings)
(.extend self.m/type-groups.acceptable-args self.m/type-groups.dict-like)
(setv self.m/type-groups.genstrings (tuple self.m/type-groups.genstrings))
#+end_src

**** Generators

#+begin_src hy
(setv self.m/type-groups.generators (, "generator" "iter" "chain" "tee"))
#+end_src

**** Excluded classes

#+begin_src hy
(setv self.m/type-groups.excluded-classes (, "type"))
#+end_src

**** Post

#+begin_src hy
(setv self.m/type-groups.dict-like (tuple self.m/type-groups.dict-like))
#+end_src

*** Subcommand

#+call: hash() :exports none

#+RESULTS:
: 20220111111603650875845

#+name: 20220111111603650875845
#+begin_src text
supercalifragilisticexpialidocious
#+end_src

Note that only via ~baking~ can subcommand-specific arguments and keyword arguments be set.

#+begin_src hy
(setv self.m/subcommand (D {})
      self.m/subcommand.default "<<20220111111603650875845>>"
      self.m/subcommand.current (D {})
      self.m/subcommand.current.unprocessed "<<20220111111603650875845>>"
      self.m/subcommand.current.intact False
      self.m/subcommand.current.processed "<<20220111111603650875845>>")
#+end_src

*** Arguments

#+begin_src hy
(setv self.m/args (D {})
      self.m/args.world []
      self.m/args.instantiated (list args)
      self.m/args.baked (D {})
      self.m/args.baked.<<20220111111603650875845>> []
      self.m/args.called []
      self.m/args.current (D {})
      self.m/args.current.unprocessed (D {})
      self.m/args.current.unprocessed.starter []
      self.m/args.current.unprocessed.regular []
      self.m/args.current.processed (D {})
      self.m/args.current.unprocessed.starter []
      self.m/args.current.unprocessed.regular [])
#+end_src

**** Keyword

#+begin_src hy
(setv self.m/kwargs (D {})
      self.m/kwargs.world (D {})
      self.m/kwargs.instantiated (D kwargs)
      self.m/kwargs.baked (D {})
      self.m/kwargs.baked.<<20220111111603650875845>> (D {})
      self.m/kwargs.called (D {})
      self.m/kwargs.current (D {})
      self.m/kwargs.current.unprocessed (D {})
      self.m/kwargs.current.unprocessed.starter (D {})
      self.m/kwargs.current.unprocessed.regular (D {})
      self.m/kwargs.current.processed (D {})
      self.m/kwargs.current.processed.starter []
      self.m/kwargs.current.processed.regular []
      self.m/kwargs.current.processed.starter-values []
      self.m/kwargs.current.processed.regular-values [])
#+end_src

*** Freezer

#+begin_src hy
(setv self.internal/freezer (.cls/freezer self.__class__ freezer- []))
#+end_src

*** Program

#+begin_src hy
(setv self.m/program (or program- "")
      self.m/base-program (or base-program- program-))
#+end_src

*** Return Categories

#+begin_src hy
(setv self.m/return-categories (,
    "stdout"
    "stderr"
    "return-codes"
    "command"
    "tea"
    "verbosity"
))
#+end_src

*** Command

#+begin_src hy
(setv self.m/command (tea))
#+end_src

*** Shortcut Keywords
**** Run

Set ~m/capture~ to ~run~, for interactive output without capturing the stream:

#+begin_src hy :tangle no
(setv self.m/run False)
#+end_src

**** Context Manager

Set ~m/context~ to ~True~:

#+begin_src hy :tangle no
(setv self.m/c True)
#+end_src

*** Settings

#+begin_src hy
(setv self.m/settings (D {})
      self.m/settings.defaults (D {})
      self.m/settings.current (D {}))
#+end_src

#+name: m/
#+begin_src emacs-lisp :var setting="" :var value=""
(format-spec "(setv self.m/%s %v)
(setv self.m/settings.defaults.m/%s (deepcopy self.m/%s))"
`((?s . ,setting) (?v . ,value)))
#+end_src

#+name: internal/
#+begin_src emacs-lisp :var setting="" :var value=""
(format-spec "(setv self.internal/%s %v)
(setv self.m/settings.defaults.m/%s (deepcopy self.internal/%s))"
`((?s . ,setting) (?v . ,value)))
#+end_src

**** Gitea

Set ~m/gitea.bool~ to ~True~, or add the program to ~m/gitea.list~ to allow this program to do something like ~git(C = path).status()~,
and set ~m/gitea.off~ to override and disable both.

Named after [[https://gitea.io/en-us/][gitea]] and my own [[https://gitlab.com/picotech/nanotech/gensing][gensing]] modules:

#+begin_src hy
(setv self.m/gitea (D {})
      self.m/gitea.list [ "git" "yadm" ]
      self.m/gitea.bool (or (in self.m/program self.m/gitea.list) False)
      self.m/gitea.off False)
#+end_src

**** Frozen Program

Return the bakery just before running the command; any type not in ~m/type-groups.acceptable-args~ will freeze the bakery:

#+begin_src hy
<<m/(setting="frozen", value="False")>>
#+end_src

**** Capture Type

Which output stream to capture; values are listed below in ~m/captures~:

#+begin_src hy
(setv self.m/captures (, "stdout" "stderr" "both" "run"))
<<internal/(setting="capture", value="\"stdout\"")>>
#+end_src

**** Shell

What shell to use:

#+begin_src hy
<<m/(setting="shell", value="None")>>
#+end_src

**** Pretty Prining

Pretty print the output:

#+begin_src hy
<<m/(setting="dazzle", value="False")>>
#+end_src

**** Ignore Output
***** Stdout

Ignore standard output:

#+begin_src hy
<<m/(setting="ignore-stdout", value="False")>>
#+end_src

***** Stderr

Ignore standard error:

#+begin_src hy
<<m/(setting="ignore-stderr", value="False")>>
#+end_src

**** Verbosity

How verbose the output should be:

#+begin_src hy
<<m/(setting="verbosity", value=0)>>
#+end_src

**** Run As

Run bakery as program; useful when ~m/program~ is a path to a script:

#+begin_src hy
<<m/(setting="run-as", value="\"\"")>>
#+end_src

**** Number of Lines

How many lines of output to return; can chop ~n~ lines off the top or bottom:

#+begin_src hy
<<internal/(setting="n-lines", value="(D { \"ordinal\" \"first\" \"number\" 0 \"std\" \"stdout\" })")>>
#+end_src

**** One Dash

Whether to use one dash for program options, such as in the case of ~find~:

#+begin_src hy
<<m/(setting="one-dash", value="False")>>
#+end_src

**** Fixed

Whether to keep underscores in program options instead of replacing them with dashes:

#+begin_src hy
<<m/(setting="fixed", value="False")>>
#+end_src

**** Intact Option

Whether to keep options as they are, not replacing underscores with dashes:

#+begin_src hy
<<m/(setting="intact-option", value="False")>>
#+end_src

**** Tiered

To use the ~m/tiered~ setting, bake the command in from before with all applicable
replacements replaced with ~{{ b.t }}~, and bake in ~m/tiered~ to True; then when
calling the command, pass in all the arguments that are going to replace the
~{{ b.t }}~ previously baked into the command.

To reset the command function, use the ~splat-~ function as necessary.

#+begin_src hy
<<m/(setting="tiered", value="False")>>
#+end_src

**** Input

Used to pass input to the ~subprocess Popen~ class; note that ~m/popen.stdin~ overrides this.

#+begin_src hy
<<m/(setting="input", value="None")>>
#+end_src

**** Regular Args

An alternate way to pass arguments to the program as a separate list:

#+begin_src hy
<<m/(setting="regular-args", value="(,)")>>
#+end_src

**** Regular Kwargs

An alternate way to pass options to the program as a separate dictionary:

#+begin_src hy
<<m/(setting="regular-kwargs", value="(D {})")>>
#+end_src

**** Context Manager

Whether the bakery is being used with a context manager:

#+begin_src hy
<<m/(setting="context", value="False")>>
#+end_src

**** Return Command

Return the command itself instead of the output of the command.

A good way to debug commands is to see what the command actually was
use the ~m/return-command~ keyword argument to return the final command.

#+begin_src hy
<<internal/(setting="return-command", value="False")>>
#+end_src

**** Print Command

Print the returned command from the setting above.

A good way to debug commands is to see what the command actually was
use the ~m/print-command~ keyword argument to print the final command.

#+begin_src hy
<<internal/(setting="print-command", value="False")>>
#+end_src

**** Print Command and Run

Print the command and continue running.

A good way to debug commands is to see what the command actually was
use the ~m/print-command-and-run~ keyword argument to print the final command and continue running.

#+begin_src hy
<<m/(setting="print-command-and-run", value="False")>>
#+end_src

**** Type of Output

~m/type~ can be any available type, such as:
- iter
- list
- tuple
- set
- frozenset

#+begin_src hy
<<m/(setting="type", value="iter")>>
#+end_src

**** Split Output By Whitespace

Split the output by newlines, tabs, spaces, etc.

#+begin_src hy
<<m/(setting="split", value="False")>>
#+end_src

**** Use Single Forward Slash Instead of Dash

Use a single forward slash instead of a dash for options, as ~DOS~ expects:

#+begin_src hy
<<m/(setting="dos", value="False")>>
#+end_src

**** Wait

- If set to True, ~m/capture = "run"~ will wait for the process to finish before returning an addict dictionary of values depending on ~m/return~ and ~m/verbosity~
- If set to False, ~m/capture = "run"~ will return the ~Popen~ object
- If set to None, ~m/capture = "run"~ will wait for the process to finish before returning None

#+begin_src hy
<<m/(setting="wait", value="True")>>
#+end_src

**** Popen

A dictionary used to pass options to the ~subprocess Popen~ class:

#+begin_src hy
<<m/(setting="popen", value="(D {})")>>
#+end_src

**** Chunk Size

Chunk size used when reading with ~m/capture = "run"~:

#+begin_src hy
<<m/(setting="chunk-size", value=512)>>
#+end_src

**** Sudo

May be a string of length 1, and value ~i~ or ~s~, or a boolean.

If [[https://gitlab.com/picotech/nanotech/gensing][tea or frosting objects]], or dict-like object, must be in the form {"i" : user} or {"s" : user},
to use or not use the configuration files of the specified user.

#+begin_src hy
<<internal/(setting="sudo", value="False")>>
#+end_src

**** Debug

Print all the current values after attempting to return the result of the command:

#+begin_src hy
<<m/(setting="debug", value="False")>>
#+end_src

*** End of Init

#+begin_src hy
)
#+end_src

** Miscellaneous
*** Magic String Output

#+begin_src hy
(defn misc/magic-string-output [self output]
      (return (if (not (.misc/type-name-is-string self :type/type (type output)))
                  "Sorry! The bakery is currently frozen, debugging, or has returned a Popen!"
                  output)))
#+end_src

*** Recursive Unmangle

#+begin_src hy
(defn misc/recursive-unmangle [self dct]
      (return (D (dfor [key value]
                       (.items dct)
                       [(unmangle key)
                        (if (isinstance value dict)
                            (.misc/recursive-unmangle self value)
                            value)]))))
#+end_src

*** Type Name is String

#+begin_src hy
(defn misc/type-name-is-string [self [type/type None]]
      (return (in (. (or type/type self.m/type) __name__) self.m/type-groups.reprs)))
#+end_src

*** Return None if Type Name is String

#+begin_src hy
(defn misc/return-none-if-tnis [self [type/type None]]
      (return (if (.misc/type-name-is-string self :type/type type/type) "None" None)))
#+end_src

*** Reset All

#+begin_src hy
(defn m/reset-all [self]
      (.reset- self)
      (.command/reset self))
#+end_src

** Convert
*** Generator

#+begin_src hy
(defn convert/generator [self input] (yield-from input))
#+end_src

*** Type

#+begin_src hy
(defn convert/type [self input [type/type None]]
    (setv type/type/type (or type/type self.m/type))
    (if (is input None) (return (.misc/return-none-if-tnis self :type/type type/type/type)))
    (if (and input (isinstance input frosting))
        (let [frosted-input (input)]
             (cond [(isinstance frosted-input str)
                    (setv input [(.fill (TextWrapper :break-long-words False :break-on-hyphens False) frosted-input)])]
                   [(is frosted-input None) (return (.misc/return-none-if-tnis self :type/type type/type/type))]
                   [(isinstance frosted-input int) (if (.misc/type-name-is-string self :type/type type/type/type)
                                                       (return (pretty-repr frosted-input))
                                                       (return frosted-input))])))
    (cond [(.misc/type-name-is-string self :type/type type/type/type) (return (.join "\n" input))]
          [(in type/type/type.__name__ self.m/type-groups.generators) (return (.convert/generator self input))]
          [True (return (type/type/type input))]))
#+end_src

** Subcommand
*** Get

#+begin_src hy
(defn subcommand/get [self #** kwargs]
      (setv self.m/subcommand.current.intact (.cls/get-attr self.__class__ kwargs "m/intact-subcommand"))
      (setv subcommand (.cls/get-attr self.__class__ kwargs "m/subcommand" :default self.m/subcommand.default))
      (if (!= subcommand self.m/subcommand.default)
          (setv self.m/subcommand.current.unprocessed subcommand)))
#+end_src

*** Process

#+begin_src hy
(defn subcommand/process [self]
    (setv self.m/subcommand.current.processed (if self.m/subcommand.current.intact
                                                  self.m/subcommand.current.unprocessed
                                                  (.replace (unmangle self.m/subcommand.current.unprocessed) "_" "-"))))
#+end_src

** Variables
*** Set Defaults

#+begin_src hy
(defn var/set-defaults [self]
      (for [[key value] (.items self.m/settings.defaults)]
           (setattr self key (deepcopy value))))
#+end_src

*** Setup

#+begin_src hy
(defn var/setup [self #* args [subcommand- "<<20220111111603650875845>>"] #** kwargs]
    (.var/set-defaults self)

    (setv self.m/args.world (or (. (.origin- self) m/args world) []))
    (setv self.m/kwargs.world (or (. (.origin- self) m/kwargs world) (D {})))

    (if (= subcommand- self.m/subcommand.default)
        (do (.subcommand/get self #** self.m/kwargs.world)
            (.subcommand/get self #** self.m/kwargs.instantiated)
            (.subcommand/get self #** (. self m/kwargs baked [subcommand-]))
            (.subcommand/get self #** kwargs))
        (setv self.m/subcommand.current.unprocessed subcommand-))
    (if (not self.m/subcommand.current.unprocessed) (setv self.m/subcommand.current.unprocessed self.m/subcommand.default))
    (.subcommand/process self)

    (setv self.m/args.called args)
    (setv self.m/kwargs.called kwargs)

    (.var/process-all self #* args #** kwargs)

    (.var/apply self))
#+end_src

*** Reset

Note that ~subcommand~ is only really needed here to help reset the baked arguments and keyword arguments.

#+begin_src hy
(defn reset- [
            self
            [world False]
            [instantiated False]
            [baked False]
            [args False]
            [kwargs False]
            [all-subs False]
            [subcommand "<<20220111111603650875845>>"]
            [set-defaults True]]
      (for [m (, "settings" "subcommand" "args" "kwargs")]
           (assoc (getattr self (mangle (+ "m/" m))) "current" (D {})))
      (setv self.m/args.called [])
            self.m/kwargs.called (D {})
      (if world
          (for [store (.chain- self)]
               (if args (setv store.m/args.world []))
               (if kwargs (setv store.m/kwargs.world (D {})))))
      (if instantiated
          (do (if args (setv self.m/args.instantiated []))
              (if kwargs (setv self.m/args.instantiated (D {})))))
      (if baked
          (do (if args
                  (if all-subs
                      (do (setv self.m/args.baked (D {}))
                          (assoc self.m/args.baked self.m/subcommand.default []))
                          (assoc self.m/args.baked subcommand [])))
              (if kwargs
                  (if all-subs
                      (do (setv self.m/kwargs.baked (D {}))
                          (assoc self.m/kwargs.baked self.m/subcommand.default (D {})))
                          (assoc self.m/kwargs.baked subcommand (D {}))))))
      (if set-defaults (.var/set-defaults self)))
#+end_src

*** Process

#+begin_src hy
(defn var/process-all [self #* args #** kwargs]
      (.var/process-args self #* self.m/args.world)
      (.var/process-args self #* self.m/args.instantiated)
      (.var/process-args self #* (. self m/args baked [self.m/subcommand.current.unprocessed]))
      (.var/process-args self #* args)

      (.var/process-kwargs self #** self.m/kwargs.world)
      (.var/process-kwargs self #** self.m/kwargs.instantiated)
      (.var/process-kwargs self #** (. self m/kwargs baked [self.m/subcommand.current.unprocessed]))
      (.var/process-kwargs self #** kwargs))
#+end_src

**** Arguments

#+begin_src hy
(defn var/process-args [self #* args [starter False]]
      (for [arg args]
           (if (isinstance arg (tuple self.m/type-groups.acceptable-args))
               (if (isinstance (. self m/args current unprocessed [(if starter "starter" "regular")]) list)
                   (.append (. self m/args current unprocessed [(if starter "starter" "regular")]) arg)
                   (assoc self.m/args.current.unprocessed (if starter "starter" "regular") [arg]))
               (do (setv self.m/settings.current.m/frozen True)))))
#+end_src

**** Keyword Arguments

#+begin_src hy
(defn var/process-kwargs [self #** kwargs]
      (defn inner [itr [starter False]]
            (for [[key value] (.items itr)]
                 (if (setx var/process/key-prefix (.cls/is-attr self.__class__ key))
                     (let [var/process/key (.cls/process-attr self.__class__ key var/process/key-prefix)]
                          (cond [(= var/process/key "m/starter-args")
                                 (.var/process-args self #* (if (isinstance value str) (, value) value) :starter True)]
                                [(= var/process/key "m/starter-kwargs") (inner value :starter True)]
#+end_src

The values in ~m/regular-args~ will always be appended to ~self.m/args.current.regular~,
since ~m/regular-args~ is a keyword argument.

#+begin_src hy
                                [(= var/process/key "m/regular-args") (.var/process-args self #* value)]
#+end_src

Note that, depending on where ~m/regular-kwargs~ is in the keyword arguments of the function call,
its values will replace any prexisting values of the same type; for example, in the following case,
where ~m/frozen~ is True, while ~m/regular-kwargs.frozen~ is False:
- If ~m/regular-kwargs~ is before ~m/frozen~, the value of ~m/frozen~ will replace the value of ~m/regular-kwargs.frozen~, and final value of ~m/frozen~ will be True
- If ~m/regular-kwargs~ is after ~m/frozen~, the value of ~m/regular-kwargs.frozen~ will replace the value of ~m/frozen~, and final value of ~m/frozen~ will be False
In other words, the values of whichever comes first will be replaced by the value of whichever comes second.

#+begin_src hy
                                [(= var/process/key "m/regular-kwargs") (inner value)]
#+end_src

Adapted from [[https://stackoverflow.com/users/2988730/mad-physicist][Mad Physicist's]] answer [[https://stackoverflow.com/a/70794425/10827766][here]]:

#+begin_src hy
                                [(let [trimmed-attr (-> self.__class__ (.cls/trim-attr-prefix var/process/key) (get 1))]
                                      (and (not (in trimmed-attr self.m/type-groups.excluded-classes))
                                           (class? (setx literal-attr (.get (globals) trimmed-attr (getattr builtins trimmed-attr None))))
                                           value))
                                 (setv self.m/settings.current.m/type literal-attr)]
#+end_src

#+begin_src hy
                                [True (if (not (in var/process/key (, "m/subcommand")))
                                          (assoc self.m/settings.current key value))]))
                     (assoc (. self m/kwargs current unprocessed [(if starter "starter" "regular")]) key value))))
      (inner kwargs))
#+end_src

*** Apply

#+begin_src hy
(defn var/apply [self]
    (for [[key value] (.items self.m/settings.current)]
         (setattr self key value)))
#+end_src

** Command

The general command string will end up like this:

#+begin_src hy :tangle no
f"{m/shell} -c (or {m/freezer} {m/program})
               {m/kwargs.current.processed.starter}
               {m/subcommand.current.processed}
               {m/args.current.processed.starter}
               {m/kwargs.current.processed.regular}
               {m/args.current.processed.regular}"
#+end_src

*** Reset

#+begin_src hy
(defn command/reset [self]
      (if (not self.m/frozen)
          (setv self.m/command (tea))))
#+end_src

*** Process

#+begin_src hy
(defn command/process-all [self]
      (for [i (range 2)]
           (.command/process-args self :starter i)
           (.command/process-kwargs self :starter i)))
#+end_src

**** Arguments

#+begin_src hy
(defn command/process-args [self [starter False]]
      (for [arg (. self m/args current unprocessed [(if starter "starter" "regular")])]
           (setv command/process-args/arg (cond [(isinstance arg self.m/type-groups.genstrings) (arg)]
                                                [(isinstance arg int) (str arg)]
                                                [(isinstance arg self.__class__) (arg :m/type str)]
                                                [True arg]))
           (if (isinstance (. self m/args current processed [(if starter "starter" "regular")]) list)
               (.append (. self m/args current processed [(if starter "starter" "regular")]) command/process-args/arg)
               (assoc self.m/args.current.processed (if starter "starter" "regular") [command/process-args/arg]))))
#+end_src

**** Keyword Arguments

If the boolean value is non-truthy, don't put the argument in;
for example, if "program.subcommand([...], option = False)", then the result would be "program subcommand [...]",
i.e. without "--option".

#+begin_src hy
(defn command/process-kwargs [self [starter False]]
      (defn inner [value]
            (setv new-value (cond [(isinstance value self.m/type-groups.genstrings) (value)]
#+end_src

Be very careful here; since ~bool~ is a subclass of ~int~, we need to first check if ~value~ is an instance of ~bool~, then ~int~,
otherwise ~(isinstance value int)~ will catch both cases.

#+begin_src hy
                                  [(isinstance value bool) None]
                                  [(isinstance value int) (str value)]
#+end_src

#+begin_src hy
                                  [(isinstance value self.__class__) (value :m/type str)]
                                  [True value]))
            (return new-value))
      (for [[key value] (.items (. self m/kwargs current unprocessed [(if starter "starter" "regular")]))]
           (if value
               (let [aa (tuple (+ self.m/type-groups.acceptable-args [dict bool]))]
                    (if (isinstance value aa)
                        (if (isinstance value dict)
                            (let [no-value-options ["repeat" "repeat-with-values" "rwv"]
                                  options (+ no-value-options ["fixed" "dos" "one-dash" "value"])
                                  dct-value (.get value "value" None)]
                                 (cond [dct-value (setv command/process-kwargs/value (inner dct-value))]
                                       [(any (gfor o (.keys value) (in o no-value-options))) (setv command/process-kwargs/value None)]
                                       [True (raise (AttributeError #[f[Sorry! You must use the "value" keyword if you do not use any of the following: {(.join ", " no-value-options)}]f]))])
                                 (for [[k v] (.items value)]
                                       (if (in k options)
                                           (if v
                                               (setv command/process-kwargs/key (if (or (= k "fixed")
                                                                                        self.m/fixed)
                                                                                    key
                                                                                    (.replace (unmangle key) "_" "-"))
                                                     command/process-kwargs/key (cond [(or (= k "dos")
                                                                                           self.m/dos)
                                                                                       (+ "/" command/process-kwargs/key)]
                                                                                      [(or (= k "one-dash")
                                                                                           self.m/one-dash
                                                                                           (= (len command/process-kwargs/key) 1))
                                                                                       (+ "-" command/process-kwargs/key)]
                                                                                      [True (+ "--" command/process-kwargs/key)])
                                                     command/process-kwargs/key-values (cond [(= k "repeat") (lfor i (range (inc v)) command/process-kwargs/key)]
                                                                                             [(in k (, "repeat-with-values" "rwv"))
                                                                                              (do (setv key-values [])
                                                                                                  (for [j v]
                                                                                                       (.append key-values command/process-kwargs/key)
                                                                                                       (if (setx l (inner j))
                                                                                                           (do (if (isinstance (. self
                                                                                                                                  m/kwargs
                                                                                                                                  current
                                                                                                                                  processed
                                                                                                                                  [(if starter
                                                                                                                                       "starter-values"
                                                                                                                                       "regular-values")]) list)
                                                                                                                   (.append (. self
                                                                                                                               m/kwargs
                                                                                                                               current
                                                                                                                               processed
                                                                                                                               [(if starter
                                                                                                                                    "starter-values"
                                                                                                                                    "regular-values")]) l)
                                                                                                                   (assoc self.m/kwargs.current.processed
                                                                                                                          (if starter
                                                                                                                              "starter-values"
                                                                                                                              "regular-values") [l]))
                                                                                                               (.append key-values l))))
                                                                                                  key-values)]
                                                                                             [True None]))
                                               (setv command/process-kwargs/key None
                                                     command/process-kwargs/value None
                                                     command/process-kwargs/key-values None))
                                           (raise (AttributeError #[f[Sorry! A keyword argument value of type dict can only have the following keys: {(.join ", " options)}]f])))))
                              [True (setv command/process-kwargs/value (inner value)
                                          command/process-kwargs/key (if self.m/fixed key (.replace (unmangle key) "_" "-"))
                                          command/process-kwargs/key (cond [self.m/dos (+ "/" command/process-kwargs/key)]
                                                                           [(or self.m/one-dash
                                                                                (= (len command/process-kwargs/key) 1))
                                                                            (+ "-" command/process-kwargs/key)]
                                                                           [True (+ "--" command/process-kwargs/key)])
                                          command/process-kwargs/key-values None)])
                        (raise (TypeError #[f[Sorry! Keyword argument value "{value}" of type "{(type value)}" must be one of the following types: {(.join ", " (gfor arg aa arg.__name__))}]f])))
           (if (or command/process-kwargs/key-values
                   command/process-kwargs/key)
               (do (if (isinstance (. self m/kwargs current processed [(if starter "starter" "regular")]) list)
                       (if command/process-kwargs/key-values
                           (.extend (. self m/kwargs current processed [(if starter "starter" "regular")]) command/process-kwargs/key-values)
                           (.append (. self m/kwargs current processed [(if starter "starter" "regular")]) command/process-kwargs/key))
                       (if command/process-kwargs/key-values
                           (assoc self.m/kwargs.current.processed (if starter "starter" "regular") command/process-kwargs/key-values)
                           (assoc self.m/kwargs.current.processed (if starter "starter" "regular") [command/process-kwargs/key])))))
           (if (and command/process-kwargs/value
                    (not command/process-kwargs/key-values))
               (do (if (isinstance (. self
                                      m/kwargs
                                      current
                                      processed
                                      [(if starter
                                           "starter-values"
                                           "regular-values")]) list)
                       (.append (. self
                                   m/kwargs
                                   current
                                   processed
                                   [(if starter
                                        "starter-values"
                                        "regular-values")]) command/process-kwargs/value)
                       (assoc self.m/kwargs.current.processed
                             (if starter
                                 "starter-values"
                                 "regular-values") [command/process-kwargs/value]))
                   (if (isinstance (. self
                                      m/kwargs
                                      current
                                      processed
                                      [(if starter
                                           "starter"
                                           "regular")]) list)
                       (.append (. self
                                   m/kwargs
                                   current
                                   processed
                                   [(if starter
                                        "starter"
                                        "regular")]) command/process-kwargs/value)
                       (assoc self.m/kwargs.current.processed
                             (if starter
                                 "starter"
                                 "regular") [command/process-kwargs/value]))))))))
#+end_src

*** Create Command

#+begin_src hy
(defn command/create [self]
      (if self.m/sudo
          (if (isinstance self.m/sudo bool)
              (.append self.m/command "sudo")
              (.append self.m/command f"sudo -{(-> self.m/sudo (.keys) (iter) (next))} -u {(-> self.m/sudo (.values) (iter) (next))}")))

      (if self.m/shell
          (do (.extend self.m/command self.m/shell "-c" "'")
              (if self.m/run-as
                  (do (.glue self.m/command self.m/run-as)
                      (if self.m/freezer
                          (.extend self.m/command #* self.m/freezer)
                          (.append self.m/command self.m/program)))
                  (if self.m/freezer
                      (do (.glue self.m/command (first self.m/freezer))
                          (.extend self.m/command (cut self.m/freezer 1 -1)))
                      (.glue self.m/command self.m/program))))
          (if self.m/freezer
              (.extend self.m/command self.m/run-as #* self.m/freezer)
              (.extend self.m/command self.m/run-as self.m/program)))

      (.extend self.m/command #* self.m/kwargs.current.processed.starter)
      (if (!= self.m/subcommand.default self.m/subcommand.current.unprocessed)
          (.append self.m/command self.m/subcommand.current.processed))
      (.extend self.m/command
               #* self.m/args.current.processed.starter
               #* self.m/kwargs.current.processed.regular
               #* self.m/args.current.processed.regular)
      (if self.m/shell (.glue self.m/command "'"))
      (if self.m/tiered
          (let [tier "{{ b.t }}"
                replacements (+ self.m/kwargs.current.processed.starter-values
                                self.m/args.current.processed.starter
                                self.m/kwargs.current.processed.regular-values
                                self.m/args.current.processed.regular)
                to-be-replaced (.count (.values self.m/command) tier)]
               (if (= to-be-replaced (len replacements))
                   (for [[index kv] (.items self.m/command :indexed True)]
                        (if (= kv.value tier)
                            (assoc self.m/command kv.key (get replacements index)))))
                   (raise (ValueError "Sorry! The number of tiered replacements must be equal to the number of arguments provided!")))))
#+end_src

** Output
*** Return

#+begin_src hy
(defn return/output [self]
      (cond [self.m/frozen (return (deepcopy self))]
            [self.m/return-command (return (.m/command self))]
            [True (let [output (.return/process self)]
                       (if (isinstance output dict)
                           (do (setv [peek-value output.stderr] (peek output.stderr :return-first 2)
                                     stds (, "out" "err"))
                               (if (and peek-value
                                        (not self.m/ignore-stderr))
                                   (raise (SystemError (+ f"In trying to run `{(.m/command self)}':\n\n" (.join "\n" output.stderr)))))
                               (for [[std opp] (zip stds (py "stds[::-1]"))]
                                    (setv stdstd (+ "std" std)
                                          stdopp (+ "std" opp))
                                    (if (< self.m/verbosity 1)
                                        (if (= self.m/capture stdstd)
                                            (del (get output stdopp)))))))
                       (return output))]))
#+end_src

**** Process

#+begin_src hy
(defn return/process [self]
    (if (.m/command self)
        (do (setv process (.m/popen-partial self))
            (cond [(is self.m/wait None) (with [p (process :pp-stdout DEVNULL :pp-stderr DEVNULL)]
                                               (return (.misc/return-none-if-tnis self)))]
                  [self.m/wait (with [p (process)]
                                     (setv return/process/return (D {}))
                                     (for [std (, "out" "err")]
                                          (setv chained []
                                                stdstd (+ "std" std))
                                          (if (setx output (getattr p stdstd))
                                              (for [line output] (setv chained (chain
                                                   chained
                                                   [(if (isinstance line (, bytes bytearray)) (.strip (.decode line "utf-8")) (.strip line))]))))
                                              (assoc return/process/return stdstd (iter chained)))
                                     (.wait p)
                                     (if (> self.m/verbosity 0)
                                         (setv return/process/return.returns.code p.returncode
                                               ;; return/process/return.returns.codes p.returncodes
                                               return/process/return.command.bakery (.m/command self)
                                               return/process/return.command.subprocess p.args
                                               return/process/return.pid p.pid))
                                     (if (> self.m/verbosity 1)
                                         (setv return/process/return.tea self.m/command
                                               return/process/return.subcommand self.m/subcommand))
                                     (if (not (and (is self.m/n-lines.number None)
                                                   (.misc/type-name-is-string self)))
                                         (let [trim-part (partial trim :ordinal self.m/n-lines.ordinal
                                                                       :number self.m/n-lines.number

                                                                       ;; TODO: After converting `nanite' / `nanotech' to `hy', change this to `type-'
                                                                       :_type self.m/type

                                                                       :ignore-check True)]
                                              (if (in self.m/n-lines.std (, "stdout" "both"))
                                                  (setv return/process/return.stdout (trim-part :iterable return/process/return.stdout)))
                                              (if (in self.m/n-lines.std (, "stderr" "both"))
                                                  (setv return/process/return.stderr (trim-part :iterable return/process/return.stderr)))))
                                     (return return/process/return))]
                  [True (return (process))]))
        (return (.misc/return-none-if-tnis self))))
#+end_src

**** Frosting

#+begin_src hy
(defn return/frosting [self]
      (setv output (.return/output self)
            frosted-output (if (and (isinstance output self.m/type-groups.dict-like)
                                    (= (len output) 1))
                               (-> output (.values) (iter) (next))
                               output)
            dict-like-frosted-output (isinstance frosted-output self.m/type-groups.dict-like)
            frosted-output (if self.m/dazzle
                               (cond [dict-like-frosted-output frosted-output]
                                     [(coll? frosted-output) (list frosted-output)]
                                     [True [frosted-output]])
                               frosted-output))
      (if self.m/print-command-and-run (print (.m/command self)))
      (cond [(or self.m/frozen (= self.m/wait False)) (return frosted-output)]
            [self.m/print-command (print frosted-output)]
            [self.m/dazzle (if dict-like-frosted-output
                               (for [cat frosted-output]
                                    (setv outcat (get output cat))
                                    (if (or (isinstance outcat int)
                                            (isinstance outcat str))
                                        (print f"{cat}: {outcat}")
                                        (do (if (not (in cat self.m/captures))
                                                (print (+ cat ": ")))
                                            (if (= cat "return-codes")
                                                (print outcat)
                                                (for [line outcat]
                                                     (print line))))))
                               (for [line frosted-output]
                                    (print line)))])
      (cond [dict-like-frosted-output
             (for [std (, "out" "err")]
                  (setv stdstd (+ "std" std))
                  (if (hasattr frosted-output stdstd)
                      (let [new-frosted-output (get frosted-output stdstd)]
                           (if self.m/split
                               (setv new-frosted-output (.cls/split-and-flatten self.__class__ new-frosted-output)))
                           (assoc frosted-output stdstd (.convert/type self new-frosted-output))))
                  (else (return new-frosted-output)))]
            [(is self.m/wait None) (return (.misc/return-none-if-tnis self))]
            [True (let [new-frosted-output (frosting frosted-output self.m/capture)]
                       (if self.m/split
                           (setv new-frosted-output (.cls/split-and-flatten self.__class__ new-frosted-output)))
                       (return (.convert/type self new-frosted-output)))]))
#+end_src

*** Popen Partial

#+begin_src hy
(defn m/popen-partial [self [stdout None] [stderr None]]
      (setv pp-stdout (cond [stdout]
                            [(= self.m/capture "stderr") (.get self.m/popen "stdout" DEVNULL)]
                            [(= self.m/capture "run") (.get self.m/popen "stdout" None)]
                            [True (if self.m/ignore-stdout
                                      (.get self.m/popen "stdout" DEVNULL)
                                      (.get self.m/popen "stdout" PIPE))])
            pp-stderr (or stderr (if (= self.m/capture "run")
                          (.get self.m/popen "stderr" None)
                          (if self.m/ignore-stderr
                              (.get self.m/popen "stderr" DEVNULL)
                              (.get self.m/popen "stderr" PIPE))))
            bufsize (.get self.m/popen "bufsize" -1)
            universal-newlines (.get self.m/popen "universal-newlines" None)
            universal-text (if (= bufsize 1)
                               True
                               universal-newlines)
            shell (.get self.m/popen "shell" (bool self.m/freezer))
            command (.m/command self)
            executable (if (setx exe (.get self.m/popen "executable" None)) (fullpath exe) exe))
      (return (partial Popen
                       (if self.m/freezer
                           command
                           (if shell
                               (join (split command))
                               (split command)))
                       :bufsize bufsize
                       :stdin (.get self.m/popen "stdin" self.m/input)
                       :stdout pp-stdout
                       :stderr pp-stderr
                       :executable executable
                       :universal-newlines universal-text
                       :text universal-text
                       :shell shell
                       #** self.m/popen)))
#+end_src

** Run

#+begin_src hy
(defn m/spin [self #* args [subcommand- "<<20220111111603650875845>>"] #** kwargs]
      (try (.var/setup self #* args :subcommand- subcommand- #** kwargs)
           (.command/process-all self)
           (.command/create self)
           (return (.return/frosting self))
           (finally (if self.m/debug (.inspect- self))
                    (.m/reset-all self))))
#+end_src

** Apply Pipe or Redirect

#+begin_src hy
(defn m/apply-pipe-redirect [self pr value]
    (setv is-milcery (isinstance value self.__class__))
    (defn inner [v]
          (let [type-string (.join ", " (gfor t (+ (list self.m/type-groups.genstrings)
                                                   self.m/type-groups.this-class-subclass
                                                   [str]) t.__name__))]
               (return (cond [(isinstance v self.m/type-groups.genstrings) [(v)]]
                             [is-milcery (or v.m/freezer (.values v.m/command) [v.m/program])]
                             [(isinstance v str) [v]]
                             [True (raise (NotImplemented f"Sorry! Value '{v}' can only be of the following types: {type-string}"))]))))
#+end_src

If the value is a tuple, assume the first item is the value itself, while the second item is the pr;
this allows for more compilcated redirects, such as ~&>~, ~2>&1~, etc.

#+begin_src hy
    (if (isinstance value tuple)
        (if (= (len value) 2)
            (setv processed-value (inner (first value))
                  processed-pr (get value 1))
            (raise (NotImplemented "Sorry! A tuple value may only contain 2 items: (value, pr)")))
        (setv processed-value (inner value)
              processed-pr pr))
#+end_src

#+begin_src hy
    (setv kwargs {}
          base-program- (or self.m/base-program self.m/program)
#+end_src

Note that ~freezer-~ will always use the ~m/freezer~ value from the bakery on the left-hand side of the operation calling it:

#+begin_src hy
          freezer- (+ (or self.m/freezer (.values self.m/command) [self.m/program]) [processed-pr processed-value]))
#+end_src

#+begin_src hy
    (.update kwargs (.cls/remove-if-not-attr self.__class__ self.m/kwargs.world))
    (if is-milcery (.update kwargs (.cls/remove-if-not-attr value.__class__ value.m/kwargs.world)))

    (.update kwargs (.cls/remove-if-not-attr self.__class__ self.m/kwargs.instantiated))
    (if is-milcery (.update kwargs (.cls/remove-if-not-attr value.__class__ value.m/kwargs.instantiated)))

    (.update kwargs
             (.cls/remove-if-not-attr self.__class__ (. self m/kwargs baked [(or self.m/subcommand.current.unprocessed self.m/subcommand.default)])))
    (if is-milcery
        (.update kwargs (.cls/remove-if-not-attr value.__class__ (. value
                                                                    m/kwargs
                                                                    baked
                                                                    [(or value.m/subcommand.current.unprocessed value.m/subcommand.default)]))))

    (.update kwargs (.cls/remove-if-not-attr self.__class__ self.m/kwargs.called))
    (if is-milcery (.update kwargs (.cls/remove-if-not-attr value.__class__ value.m/kwargs.called)))

    (return (.__class__ self :freezer- freezer-
                             :base-program- base-program-
                             #** kwargs)))
#+end_src

** Funktions
*** Miscellaneous

#+begin_src hy
(defn deepcopy- [self #* args [subcommand- "<<20220111111603650875845>>"] #** kwargs]
      (setv cls (deepcopy self))
      (.bake- cls #* args :instantiated- True :m/subcommand subcommand- #** kwargs)
      (return cls))
#+end_src

*** Freeze

#+begin_src hy
(defn freeze- [self] (setv self.m/frozen True))
#+end_src

**** Defrost

#+begin_src hy
(defn defrost- [self] (setv self.m/frozen self.m/settings.m/frozen))
#+end_src

*** Great [Insert Country Here] Bakeoff!

[["Bake"][https://amoffat.github.io/sh/sections/baking.html]] arguments and options into the command from before for specific subcommands:

#+begin_src hy
(defn bake- [self #* args [subcommand- "<<20220111111603650875845>>"] [instantiated- False] #** kwargs ]
      (.extend (if instantiated-
                   self.m/args.instantiated
                   (. self m/args baked [subcommand-])) args)
      (.update (if instantiated-
                   self.m/kwargs.instantiated
                   (. self m/kwargs baked [subcommand-])) kwargs))
#+end_src

**** Bake All

[["Bake"][https://amoffat.github.io/sh/sections/baking.html]] arguments and options into all bakeries:

#+begin_src hy
(defn bake-all- [self #* args #** kwargs ]
      (for [store (.chain- self)]
           (.extend store.m/args.world args)
           (.update store.m/kwargs.world kwargs)))
#+end_src

**** Unbake

Remove baked arguments and options; accepts keyword arguments taken by ~reset-~:

#+begin_src hy
(defn splat- [self [set-defaults False] #** kwargs] (.reset- self :baked True :set-defaults set-defaults))
#+end_src

**** Unbake All

Remove arguments and options from all bakeries; accepts keyword arguments taken by ~reset-~:

#+begin_src hy
(defn splat-all- [self [set-defaults False] #** kwargs]
      (for [store (.chain- self)]
           (.reset- self :set-defaults set-defaults #** kwargs)))
#+end_src

*** Current Values

Return an ~addict~ dictionary with all the current values for the class variables;
can be used for debugging purposes or otherwise.

#+begin_src hy
(defn current-values- [self]
      (return (D { "__slots__" (.misc/recursive-unmangle self (dfor var
                                                                    self.__slots__
                                                                    :if (!= var "__dict__")
                                                                    [var (getattr self var)]))
                   "__dict__" self.__dict__ })))
#+end_src

**** Print

Debug the current function:

#+begin_src hy
(defn inspect- [self #** kwargs] 
      (if (not kwargs)
          (setv kwargs { "all" True }))
      (inspect self #** kwargs))
#+end_src

*** Bakeries
**** Original

Get the original bakery object:

#+begin_src hy
(defn origin- [self] (return (. (first self.__class__.m/stores) __callback__)))
#+end_src

**** All

Return a list of all bakeries:

#+begin_src hy
(defn chain- [self] (return (lfor store self.__class__.m/stores store.__callback__)))
#+end_src

** Magic Methods

Adapted from [[https://realpython.com/primer-on-python-decorators/][Primer on Python Decorators]]:

#+call: hash() :exports none

#+RESULTS:
: 20220101204858374153059

#+name: 20220101204858374153059
#+begin_src emacs-lisp :var subcommand='nil
(format-spec
"(cond [(or (.cls/get-attr self.__class__ kwargs \"m/context\" False)
           (.cls/get-attr self.__class__ kwargs \"m/c\" False))
       (return (.deepcopy- self #* args %s #** kwargs))]
      [True (return (.m/spin self #* args %s #** kwargs))])"
    `((?s . ,(if subcommand ":subcommand- subcommand" ""))))
#+end_src

*** __call__

#+begin_src hy
(defn __call__ [
        self
        #* args
        [args-before-func (,)]
        #** kwargs ]
    (if (and (not self.m/gitea.off)
             (or self.m/gitea.bool
                 (in self.m/program self.m/gitea.list)))
        (return (.deepcopy- self :m/starter-args args :m/starter-kwargs kwargs))
        <<20220101204858374153059()>>))
#+end_src

*** __setattr__

#+begin_src hy
(defn __setattr__ [self attr value] (.__setattr__ (super) (.cls/process-if-attr self.__class__ attr) value))
#+end_src

*** __getattr__

#+begin_src hy
(defn __getattr__ [self subcommand]
    (if (setx attr (.cls/process-if-attr self.__class__ subcommand :return-bool True))
        (getattr self __getattr__/attr (raise (AttributeError f"Sorry! `{(unmangle subcommand)}' doesn't exist as an attribute!")))
        (do (defn inner [
                    #* args
                    [args-before-func (,)]
                    #** kwargs ]
                  <<20220101204858374153059(subcommand='t)>>)
            (return inner))))
#+end_src

*** __copy__

Note that copies have ~m/frozen~ set to its default.

Adapted from [[https://gist.github.com/shadowrylander/a4d861fc37d381b8edc4b8e7793000d1][here]]:

#+begin_src hy
(defn __copy__ [self]
#+end_src

#+begin_quote
Create a new instance
#+end_quote

#+begin_src hy
    (setv cls self.__class__
          result (.__new__ cls cls)
#+end_src

#+begin_quote
Get all ~__slots__~ of the derived class
#+end_quote

#+begin_src hy
          slots (.from-iterable chain (lfor s self.__class__.__mro__ (getattr s "__slots__" []))))
#+end_src

#+begin_quote
Copy all attributes
#+end_quote

#+begin_src hy
    (for [var slots] (if (not (in var (, "__weakref__"))) (setattr result var (copy (getattr self var)))))
    (.update result.__dict__ self.__dict__)
#+end_src

Reset ~m/frozen~:

#+begin_src hy
    (setv result.m/frozen result.m/settings.defaults.m/frozen)
#+end_src

#+begin_quote
Return updated instance
#+end_quote

#+begin_src hy
    (return result))
#+end_src

*** __deepcopy__

Note that deepcopies have ~m/frozen~ set to its default.

Adapted from [[https://gist.github.com/shadowrylander/a4d861fc37d381b8edc4b8e7793000d1][here]]:

#+begin_src hy
(defn __deepcopy__ [self memo]
#+end_src

#+begin_quote
Create a new instance
#+end_quote

#+begin_src hy
    (setv cls self.__class__
          result (.__new__ cls cls))
#+end_src

#+begin_quote
Don't copy self reference
#+end_quote

#+begin_src hy
    (assoc memo (id self) result)
#+end_src

#+begin_quote
Don't copy the cache - if it exists
#+end_quote

#+begin_src hy
    (if (and (hasattr self "m/cache") self.m/cache) (assoc memo (id self.m/cache) (.__new__ self.m/cache dict)))
#+end_src

#+begin_quote
Get all ~__slots__~ of the derived class
#+end_quote

#+begin_src hy
    (setv slots (.from-iterable chain (lfor s self.__class__.__mro__ (getattr s "__slots__" []))))
#+end_src

#+begin_quote
Deep copy all other attributes
#+end_quote

#+begin_src hy
    (for [var slots] (if (not (in var (, "__weakref__"))) (setattr result var (deepcopy (getattr self var) memo))))
    (for [[k v] (.items self.__dict__)] (setattr result k (deepcopy v memo)))
#+end_src

Reset ~m/frozen~:

#+begin_src hy
    (setv result.m/frozen result.m/settings.defaults.m/frozen)
#+end_src

#+begin_quote
Return updated instance
#+end_quote

#+begin_src hy
    (return result))
#+end_src

*** __iter__

#+begin_src hy
(defn __iter__ [self]
    (setv self.m/n 0
          self.m/output (.m/spin self))
    (return self))
#+end_src

*** __next__

#+begin_src hy
(defn __next__ [self]
      (try (setv output-len (len self.m/output))
           (except [TypeError]
                   (return (next self.m/output)))
           (else (hyrulem/n output-len)
                     (do (+= self.m/n 1)
                         (return (get self.m/output (dec self.m/n))))
                     (raise StopIteration))))
#+end_src

*** __str__

If ~__str__~ doesn't exist, ~__repr__~ called by ~(inspect self)~ trigger in infinite loop when getting the title of the report.

#+begin_src hy
(defn __str__ [self] (return (or (.m/command self) f"<{self.__class__.__module__}.{self.__class__.__name__} object at {(hex (id self))}>")))
#+end_src

*** __repr__

If ~__str__~ doesn't exist, ~__repr__~ called by ~(inspect self)~ trigger in infinite loop when getting the title of the report.

#+begin_src hy
(defn __repr__ [self] (.inspect- self) (return (str self)))
#+end_src

*** __or__

#+begin_src hy
(defn __or__ [self value] (return (.m/apply-pipe-redirect self "|" value)))
#+end_src

*** __and__

#+begin_src hy
(defn __and__ [self value] (return (.m/apply-pipe-redirect self "| tee" value)))
#+end_src

*** __add__

#+begin_src hy
(defn __add__ [self value] (return (.m/apply-pipe-redirect self "| tee -a" value)))
#+end_src

*** __lt__

#+begin_src hy
(defn __lt__ [self value] (return (.m/apply-pipe-redirect self "<" value)))
#+end_src

*** __lshift__

#+begin_src hy
(defn __lshift__ [self value] (return (.m/apply-pipe-redirect self "<<" value)))
#+end_src

*** __gt__

#+begin_src hy
(defn __gt__ [self value] (return (.m/apply-pipe-redirect self ">" value)))
#+end_src

*** __rshift__

#+begin_src hy
(defn __rshift__ [self value] (return (.m/apply-pipe-redirect self ">>" value)))
#+end_src

*** __ror__

#+begin_src hy
(defn __or__ [self value] (return (.m/apply-pipe-redirect self "|" value)))
#+end_src

*** __rand__

#+begin_src hy
(defn __and__ [self value] (return (.m/apply-pipe-redirect self "| tee" value)))
#+end_src

*** __radd__

#+begin_src hy
(defn __add__ [self value] (return (.m/apply-pipe-redirect self "| tee -a" value)))
#+end_src

*** __rlt__

#+begin_src hy
(defn __lt__ [self value] (return (.m/apply-pipe-redirect self "<" value)))
#+end_src

*** __rlshift__

#+begin_src hy
(defn __lshift__ [self value] (return (.m/apply-pipe-redirect self "<<" value)))
#+end_src

*** __rgt__

#+begin_src hy
(defn __gt__ [self value] (return (.m/apply-pipe-redirect self ">" value)))
#+end_src

*** __rrshift__

#+begin_src hy
(defn __rshift__ [self value] (return (.m/apply-pipe-redirect self ">>" value)))
#+end_src

*** __enter__

#+begin_src hy
(defn __enter__ [self] (return (deepcopy self)))
#+end_src

*** __exit__

#+begin_src hy
(defn __exit__ [self exception-type exception-val exception-traceback] False)
#+end_src

** End of Milcery

#+begin_src hy
)
#+end_src