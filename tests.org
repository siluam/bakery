#+name: 75a09b5c-aadf-4346-aba6-145d5cc6dd4b
#+begin_src hy
(import bakery [ls])
(import oreo)
(import oreo [nots?])
(import pathlib [Path])
(import pytest [mark])
(require hyrule [->])
(setv cookies (/ (.resolve (. (Path __file__) parent parent) :strict True) "cookies"))
(setv cookies-ls (.ls oreo cookies))
(setv assorted-cookies (.ls oreo cookies :sort True))
#+end_src

* tests
:PROPERTIES:
:header-args:hy+: :tangle (meq/tangle-path) :prologue (meq/get-block "75a09b5c-aadf-4346-aba6-145d5cc6dd4b")
:header-args:python+: :tangle (meq/tangle-path)
:END:

** test-list-output.hy

#+begin_src hy
(defn [mark.list-output] test-list-output-short [] (-> cookies (ls :m/list True) (isinstance list) assert))
(defn [mark.list-output] test-list-output-long [] (-> cookies (ls :m/type list) (isinstance list) assert))
#+end_src

** test-sorted-output.hy

#+begin_src hy
(import bakery [frosting])
(defn [mark.sorted-output (.parametrize mark "opts" #({ "m/list" True } { "m/type" frosting } { "m/frosting" True }))] test-sorted-output [opts]
      (assert (= assorted-cookies (ls cookies :m/sort None #** opts))))
(defn [mark.sorted-output] test-sorted-key-output []
      (let [ func (fn [item] (if (.isnumeric item) (int item) -1)) ]
           (assert (= (.ls oreo cookies :key func) (ls cookies :m/list True :m/sort func)))))
(defn [mark.sorted-output] test-sorted-reversed-output [] (assert (= (cut assorted-cookies None None -1) (ls cookies :m/list True :m/sort True))))
(defn [mark.sorted-output] test-sorted-dict-keyword []
      (let [ func (fn [item] (if (.isnumeric item) (int item) -1)) ]
           (assert (= (.ls oreo cookies :key func :reverse True) (ls cookies :m/list True :m/sort { "key" func "reverse" True })))))
#+end_src

** test-filtered-output.hy

#+begin_src hy
(defn not-zero? [i] (and (.isnumeric i) (not (in "0" i))))
(setv ones (sorted (gfor i cookies-ls :if (not-zero? i) i)))
(setv not-ones (sorted (gfor i cookies-ls :if (not (not-zero? i)) i)))
(defn [mark.filtered-output] test-filtered-output-function [] (-> cookies (ls :m/list True :m/sort None :m/filter not-zero?) (= ones) assert))
(defn [mark.filtered-output] test-filtered-output-collection [] (-> cookies (ls :m/list True :m/sort None :m/filter #(True not-zero?)) (= not-ones) assert))
#+end_src

** test-bakery.hy

#+begin_src hy
(import oreo [hidden?])
(defn [mark.bakery] test-bakery [] (assert (= assorted-cookies (ls :m/list True cookies :m/sort None :m/filter #(True hidden?)))))
(defn [mark.bakery] test-bakery-program-options [] (assert (= assorted-cookies (ls :m/list True :a True cookies :m/sort None :m/filter nots?))))
#+end_src

** test-context-manager.hy

Check if temporary baking with a context manager works:

#+begin_src hy
(import oreo [hidden?])
(defn [mark.context-manager] test-context-manager []
      (with [lsa (ls :a True cookies :m/context True :m/list True :m/sort None :m/filter nots?)]
            (-> assorted-cookies (= (lsa)) assert))
      (-> cookies
          (ls :m/list True :m/sort None :m/filter #(True hidden?))
          (= assorted-cookies)
          assert))
#+end_src

** test-loop.hy

#+begin_src hy
(import os [chdir])
(require oreo [with-cwd])
(defn [mark.loop] test-loop [] (with-cwd cookies (for [item ls] (assert (in item cookies-ls)))))
#+end_src

** test-progress.hy

#+begin_src hy
(defn [mark.progress] test-progress []
      (for [item (ls :a True cookies :m/progress "red")]
           (when (nots? item) (assert (in item cookies-ls)))))
#+end_src

** test-baking.hy

#+begin_src hy
(import bakery [ls :as la ls :as ld find])
(import hy [mangle] os [sep])
(defn [mark.baking] test-baking []
      (try (.bake- ls :a True cookies :m/filter nots? :m/list True :m/sort None)
           (assert (= (ls) assorted-cookies))
           (finally (.splat- ls)
                    (assert (not (in "a" (get ls.m/kwargs.baked ls.m/subcommand.default))))
                    (assert (not (in cookies (get ls.m/args.baked ls.m/subcommand.default)))))))
(defn [mark.baking] test-baking-program []
      (try (.bake- ld :m/sort True)
           (.bake- ls :programs True cookies :m/list True)
           (for [item la] (assert (in item assorted-cookies)))
           (-> assorted-cookies (cut None None -1) (= (ld)) assert)
           (finally (.splat- ld :all-classes True)
                    (assert (not (in (mangle "m/sort") (get ls.m/kwargs.baked ls.m/subcommand.default))))
                    (assert (not (in cookies (get ls.m/args.program ls.m/program)))))))
(defn [mark.baking] test-baking-all-programs [request]
      (try (.bake- ls cookies :world True :m/filter nots? :m/list True :m/sort None)
           (assert (= (ls) (cut (lfor item (find) (.removeprefix item (+ (str cookies) sep))) 1 None) assorted-cookies))
           (finally (.splat- ls :world True)
                    (assert (not (in (mangle "m/sort") (get ls.m/kwargs.baked ls.m/subcommand.default))))
                    (assert (not (in cookies (get ls.m/args.program ls.m/program))))
                    (assert (not (in (mangle "m/sort") (get find.m/kwargs.baked find.m/subcommand.default))))
                    (assert (not (in cookies (get find.m/args.program find.m/program)))))))
#+end_src

** test-module-call.hy

#+begin_src hy
(import bakery)
(defn [mark.module-call] test-module-call []
      (-> assorted-cookies (= ((bakery :program- "ls") :a True :m/list True :m/sort None :m/filter nots? cookies)) assert))
#+end_src

** test-freezing.hy

#+begin_src hy
(import bakery)
(import oreo [either?])
(defn [mark.freezing] test-freezing [] (-> [] (ls) (either? bakery) assert))
#+end_src

** test-git-remote.hy

#+begin_src hy
(import bakery [git])
(defn [mark.git-remote] test-git-status [request] (-> (git :C request.config.rootdir) (.remote :m/str True) (= "origin") assert))
#+end_src

** test-string-output.hy

#+begin_src hy
(import bakery [echo])
(defn [mark.string-output] test-string-output [] (-> "Hello!" (echo :m/str True) (= "Hello!") assert))
#+end_src

** test-split.hy

#+begin_src hy
(defn [mark.split] test-split []
      (setv six-two ["6" "5" "4" "3" "2" "09" "08" "07" "06" "05" "04" "03" "02" "00" "0" "0"])
      (-> cookies (ls :m/list True :m/split 1 :m/sort True :m/filter (fn [item] (.isnumeric item))) (= six-two) assert))
#+end_src

** test-error.hy

#+begin_src hy
(defn [mark.error] test-ignore-error [] (assert (ls :j True :m/ignore-stderr True)))
(defn [mark.error] test-stdout-error [] (assert (= (ls :j True :m/stdout-stderr True :m/str True)
                                                   "ls: invalid option -- 'j'\nTry 'ls --help' for more information.")))
(defn [mark.error] test-false-error [] (assert (= (ls :j True :m/false-stderr True) False)))
(defn [mark.error] test-replace-error []
      (assert (ls :j True :m/replace-stderr True))
      (-> (ls :j True :m/replace-stderr "replace error test") (= "replace error test") assert))
#+end_src

** test-exports.hy

#+begin_src hy
(import bakery [echo])
(defn [mark.exports] test-exports [] (-> "$FOO" (echo :m/exports { "FOO" "bar" } :m/str True) (= "bar") assert))
#+end_src

** test-piping.hy

#+begin_src hy
(import bakery [env grep tail])
(import oreo [first-last-n])
(defn [mark.piping] test-piping-first []
      (setv tails (| (ls [] :a True cookies :m/list True :m/sort None :m/filter nots?) tail))
      (-> assorted-cookies (first-last-n :last True :number 10 :type- list) (= (tails)) assert))
(defn [mark.piping] test-piping-both []
      (setv egrep (| (env [] :m/exports { "FOO" "bar" } :m/str True) (grep [] "FOO")))
      (assert (= (egrep) "FOO=bar")))
#+end_src

** test-baking-freezers.hy

#+begin_src hy
(import bakery [tail])
(import hy [mangle eval] oreo [first-last-n])
(setv tails (| (ls [] :a True cookies) tail))
(defn [mark.baking mark.piping (.parametrize mark "fhash" #(tails.m/freezer-hash (hash (tuple tails.m/freezer))))] test-bake-freezer [fhash]
      (try (.bake- ls :freezer-hash fhash :m/list True :m/sort None :m/filter nots?)
           (-> assorted-cookies (first-last-n :last True :number 10 :type- list) (= (tails)) assert)
           (-> (ls) (isinstance list) (not) assert)
           (finally (.splat- ls :freezer-hash fhash)
                    (assert (not (in (mangle "m/sort") (get tails.m/kwargs.freezer fhash)))))))
(defn [mark.baking mark.piping (.parametrize mark "cls" #(
      {}
      { "base_program" "tail" }
      { "program" "tail" }
))] test-bake-freezer-failures [cls]
      (let [ command (tails :m/return-command True) ]
           (try (.bake- tails cookies :m/list True :help True #** cls)
                (assert (= command (tails :m/return-command True)))
                (finally (.splat- tails #** cls)
                         (-> tails.m/kwargs.baked (get tails.m/subcommand.default) (get (mangle "m/type")) (!= list) assert)))))
#+end_src

** test-trim.hy

#+begin_src hy
(import bakery [cat])
(setv bulbasaur (sorted #("001: Bulbasaur" "002: Ivysaur" "003: Venusaur" ))
      last-three (sorted #("058: Growlithe" "059: Arcanine" "060: Poliwag" ))
      one-cookie (/ cookies "01"))
(defn [mark.trim] test-trim []
      (try (.bake- cat :m/list True :m/sort None)
           (-> one-cookie (cat :m/n-lines 3) (= bulbasaur) assert)
           (-> one-cookie (cat :m/n-lines #(3)) (= bulbasaur) assert)
           (-> one-cookie (cat :m/n-lines { "number" 3 }) (= bulbasaur) assert)
           (-> one-cookie (cat :m/n-lines #(True 3)) (= last-three) assert)
           (-> one-cookie (cat :m/n-lines { "last" True "number" 3 }) (= last-three) assert)
           (finally (.splat- cat))))
#+end_src