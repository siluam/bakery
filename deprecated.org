#+setupfile: ../settings/README.org
#+include: ../settings/README.org
#+property: header-args:hy :tangle yes :comments both

Inspired by [[https://amoffat.github.io/sh/][sh]] by [[https://github.com/amoffat][Andrew Moffat]].

* Imports

#+begin_src hy
(import pout weakref)
#+end_src

~From~ imports:

#+begin_src hy
(import [addict [Dict :as D]])
(import [autoslot [SlotsPlusDictMeta]])
(import [collections [OrderedDict]])
(import [copy [copy deepcopy]])
(import [functools [partial wraps]])
(import [gensing [frosting tea]])
(import [hy.contrib.pprint [pprint]])
(import [itertools [chain]])
(import [nanite [fullpath mixinport module_installed peek trim]])
(import [os [environ]])
(import [pprint [pprint :as ppprint]])
(import [shlex [join split]])
(import [subprocess [DEVNULL PIPE Popen]])
(import [textwrap [TextWrapper]])
(import [threading [local :as thread_local]])
(import [toml [load]])
(import [types [MethodType]])
(import [typing [Any Dict Generator Tuple Union]])
#+end_src

* Requires

#+begin_src hy
(require [hy.contrib.walk [let]])
#+end_src

* The Meta Class

Adapted from [[https://stackoverflow.com/a/1800999/10827766][this answer]] by [[https://stackoverflow.com/users/36433/a-coady][A. Coady]], as well as [[https://stackoverflow.com/a/31537249/10827766][this answer]] by [[https://stackoverflow.com/users/302343/timur][Timur]].

#+begin_src hy
(defclass melcery [SlotsPlusDictMeta]
#+end_src

Remember that ~metaclasses~ use ~cls~ instead of ~self~!

** Stores Getter

#+begin_src hy
#@(property (defn stores_ [cls] (return cls._stores)))
#+end_src

** Stores Setter

Adapted from [[https://stackoverflow.com/a/328882/10827766][this answer]] by [[https://stackoverflow.com/users/9567/torsten-marek][Torsten Marek]]:

#+begin_src hy
#@(stores_.setter (defn stores_ [cls value] (if (isinstance value list) (setv cls._stores None)
                                                                        (if (is cls._stores None) (setv cls._stores [value])
                                                                                                  (.append cls._stores value)))))
#+end_src

** __init__

#+begin_src hy
(defn __init__ [cls #* args #** kwargs] (setv cls.stores_ [])))
#+end_src

* The Milcery Class

#+begin_src hy
(defclass milcery [:metaclass melcery]
#+end_src

Adapted from [[the man himself][https://github.com/python/typing/issues/345#issuecomment-270814750]],
as well as from the [[https://github.com/cjrh/autoslot][autoslot]] documentation (by [[https://github.com/cjrh][Caleb Hattingh]]) [[https://github.com/cjrh/autoslot#weakref][here]]:

#+begin_src hy
(setv __slots__ ["__weakref__"])
#+end_src

** Properties
*** Flags

Return the final command:

#+begin_src hy
#@(property (defn _str [self] (return self.__str)))
#@(_str.setter (defn _str [self value]
    (setv self.__str (bool value))
    (if value (setv self.__type str))))
#+end_src

Print the final command:

#+begin_src hy
#@(property (defn _print [self] (return self.__print)))
#@(_print.setter (defn _print [self value]
                    (setv self.__print (bool value))
                    (if value (setv self._str True))))
#+end_src

Pretty print the output:

#+begin_src hy
#@(property (defn _frosting [self] (return self.__frosting)))
#@(_frosting.setter (defn _frosting [self value]
                    (setv self.__frosting (bool value))
                    (if value (setv self._type self._settings.defaults._type))))
#+end_src

**** Short Forms

Run command interactively:

#+begin_src hy
#@(property (defn _run [self] (return (= self._capture "run"))))
#@(_run.setter (defn _run [self value] (if value (setv self._capture "run"))))
#+end_src

Return output as list:

#+begin_src hy
#@(property (defn _list [self] (return (= self._type list))))
#@(_list.setter (defn _list [self value] (if value (setv self._type list))))
#+end_src

Use function as decorator:

#+begin_src hy
#@(property (defn _d [self] (return self._decorator)))
#@(_d.setter (defn _d [self value] (setv self._decorator (bool value))))
#+end_src

*** Functions

Return an ~addict~ dictionary with all the current values for the class variables;
can be used for debugging purposes or otherwise.

#+begin_src hy
#@(property (defn cv_ [self] (return (D {
    "__slots__" (dfor var self.__slots__ :if (not (= var "__dict__")) [var (getattr self var)])
    "__dict__" self.__dict__ }))))
#+end_src

Debug the current function:

#+begin_src hy
#@(property (defn debug_ [self]
    (print "########################")
    (print "# Python Pretty Print: #")
    (print "########################\n")
    (ppprint (setx cv self.cv_))
    (print "\n####################")
    (print "# Hy Pretty Print: #")
    (print "####################\n")
    (pprint cv)
    (print "\n#################")
    (print "# Verbose Pout: #")
    (print "#################")
    (.v pout cv)))
#+end_src

Get the original bakery:

#+begin_src hy
#@(property (defn origin_ [self]
    (for [store self.__class__.stores_]
        (if (not (is store None))
            (return store.__callback__)))
    (return self)))
#+end_src

Return a list of all the bakeries:

#+begin_src hy
#@(property (defn chain_ [self]
    (return (lfor store self.__class__.stores_ :if (not (is store None)) store.__callback__))))
#+end_src

*** Long Variables

#+begin_src hy
#@(property (defn _n_lines [self] (return self.__n_lines)))
#@(_n_lines.setter (defn _n_lines [self value]

    (setv ordinal (.get value "ordinal" False))
    (if ordinal
        (if (not (in ordinal (setx ordinals (, "first" "last"))))
            (let [ordinal-string (.join ", " ordinals)]
                (raise (TypeError f"Sorry! You must choose and `ordinal' from: [{ordinal-string}]"))))
        (assoc value "ordinal" "first"))

    (setv number (.get value "number" False))
    (if number
        (cond [(is number None) None]
              [(< (int number) 1) (raise (ValueError "Sorry! `n' must be greater than 0!"))])
        (assoc value "number" None))

    (setv std (.get value "std" False))
    (if std
        (if (not (in std (setx stds (, "stdout" "stderr" "both"))))
            (let [std-string (.join ", " stds)]
                (raise (TypeError f"Sorry! You must choose and `std' from: [{std-string}]")))
        (assoc value "std" "stdout")))
    
    (setv self.__n_lines (D value))))
#+end_src

*** Short Variables

Class:

#+begin_src hy
#@(property (defn _cls [self] (return self.__cls)))
#@(_cls.setter (defn _cls [self value] (setv self.__cls (._cls_check self value))))
#+end_src

Capture types, consisting of ~stdout~, ~stderr~, and both:

#+begin_src hy
#@(property (defn _capture [self] (return self.__capture)))
#@(_capture.setter (defn _capture [self value]
    (if (not (in value self._captures))
        (let [capture-string (.join ", " self._captures)]
            (raise (TypeError f"Sorry! Capture type '{value}' is not permitted! Choose from one of: [{cature-string}]"))))
    (setv self.__capture value)))
#+end_src

#+call: hash() :exports none

#+RESULTS:
: 20220110154615444882223

#+name: 20220110154615444882223
#+begin_src emacs-lisp :var value="value"
(format-spec
"(cond [(not %v) (setv self.__freezer [])]
      [(isinstance %v list)
       (do (if (not (isinstance self.__freezer list)) (setv self.__freezer []))
           (.extend self.__freezer %v)
           (setv self.__freezer (list (chain #* (lfor item (py \"[item for item in self.__freezer if item]\") (if (isinstance item list) item [item]))))
                 self._program (.join \" \" self.__freezer)))]
      [True (raise (TypeError f\"Sorry! The '_freezer' can only accept lists or non-truthy values!\"))])"
    `((?v . ,value)))
#+end_src

This tells the bakery that the program is a combination of multiple programs, such as ~ls | tail~.

#+begin_src hy
#@(property (defn _freezer [self] (return self.__freezer)))
#@(_freezer.setter (defn _freezer [self value]
    <<20220110154615444882223()>>))
#+end_src

#+call: hash() :exports none

#+RESULTS:
: 20220110160417979466972

#+name: 20220110160417979466972
#+begin_src emacs-lisp :var value="value"
(format-spec
"(cond [(not %v) (setv self.__prs {})]
      [(isinstance %v (, dict tea frosting)) (setv self.__prs %v)]
      [(and (isinstance %v tuple) (= (len %v) 4))
       (do (if (not (isinstance self.__prs (, dict tea frosting))) (setv self.__prs {}))
           (assoc self.__prs (get %v 0) { (get %v 1) (, (get %v 2) (get %v 3)) }))]
      [True (raise (TypeError f\"Sorry! '_pr' can only accept tea, frosting, dict-like objects or tuples of length 4: (pr_index, pr, left-hand-side, right-hand-side)!\"))])"
`((?v . ,value)))
#+end_src

This tells the bakery about any potential pipes and redirects in the ~_freezer~ above.

#+begin_src hy
#@(property (defn _prs [self] (return self.__prs)))
#@(_prs.setter (defn _prs [self value]
    <<20220110160417979466972()>>))
#+end_src

Use sudo:

#+begin_src hy
#@(property (defn _sudo [self] (return self.__sudo)))
#@(_sudo.setter (defn _sudo [self value]
    (if (not (isinstance value (, dict tea frosting)))
        (raise (TypeError "Sorry! '_sudo' needs to be a tea, frosting, or dict-like object!")))
    (if (> (len value) 1)
        (raise (ValueError "Sorry! The '_sudo' object can only have a single key-value item!")))
    (if (and
            value
            (-> (.keys value) next iter (in (, "i" "s")) not))
        (raise (ValueError "Sorry! The '_sudo' object can only take `i' or `s' as a key!")))
    (setv self.__sudo value)))
#+end_src

#+begin_src hy
#@(property (defn _starter_kwargs [self] (return self.__starter_kwargs)))
#@(_starter_kwargs.setter (defn _starter_kwargs [self value]
    (if (not (isinstance value (, dict tea frosting)))
        (raise (TypeError "Sorry! '_starter_kwargs' needs to be a tea, frosting, or dict-like object!")))
    (setv self.__starter_kwargs (bool value))))
#+end_src

#+begin_src hy
#@(property (defn _regular_kwargs [self] (return self.__regular_args)))
#@(_regular_kwargs.setter (defn _regular_kwargs [self value]
    (if (not (isinstance value (, dict tea frosting)))
        (raise (TypeError "Sorry! '_regular_kwargs' needs to be a tea, frosting, or dict-like object!")))
    (setv self.__regular_kwargs (bool value))))
#+end_src

** __init__

#+begin_src hy
(defn __init__ [
        self
        #* args
        [_program None]
        [_freezer None]
        [_prs None]
        [_baked_commands None]
        [_baked_settings None]
        #** kwargs]
#+end_src

*** Append bakery to list of bakeries

Adapted from [[https://stackoverflow.com/a/26626707/10827766][this answer]] by [[https://stackoverflow.com/users/100297/martijn-pieters][Martijn Pieters]], as well as [[https://stackoverflow.com/a/328882/10827766][this answer]] by [[https://stackoverflow.com/users/9567/torsten-marek][Torsten Marek]]:

#+begin_src hy
(setv self.__class__.stores_ (.ref weakref self self))
#+end_src

*** Program

#+begin_src hy
(setv self._program (or _program ""))
#+end_src

*** Frozen Program

#+begin_src hy
<<20220110154615444882223(value="_freezer")>>
<<20220110160417979466972(value="_prs")>>
#+end_src

*** Final Command

#+begin_src hy
(setv self._command (D {}))
(setv self._command.baked (or _baked_commands (D {})))
#+end_src

*** Settings

#+begin_src hy
(setv self._settings (D {}))
(setv self._settings.baked (or _baked_settings (D {})))
(setv self._settings.defaults (D {
#+end_src

#+begin_src hy
"_capture" "stdout"
"_run" False
"_shell" None
"_frosting" False
"_ignore_stderr" False
"_ignore_stdout" False
"_verbosity" (int (.get environ "verbose_bakery" 0))
"_run_as" ""
"_n_lines" (D { "ordinal" "first" "number" None "std" "stdout" })
"_kwarg_one_dash" False
"_fixed_key" False
"_tiered" False
"_timeout" None
"_input" None
"_regular_args" (,)
"_decorator" False
"_exe_env" False
#+end_src

A good way to debug commands is to see what the command actually was;
use the ~_str~ keyword argument to return the final command, and the ~_print~ keyword argument to print the final command.

#+begin_src hy
"_str" False
"_print" False
#+end_src

~_type~ can be any type, such as:
- iter
- list
- tuple
- set
- frozenset

#+begin_src hy
"_type" iter
#+end_src

This setting will use a single forward slash instead of a dash for options:

#+begin_src hy
"_dos" False
#+end_src

- If set to True, ~_capture = "run"~ will wait for the process to finish before returning an addict dictionary of values depending on ~_return~ and ~_verbosity~
- If set to False, ~_capture = "run"~ will return the sarge Pipeline object
- If set to None, ~_capture = "run"~ will wait for the process to finish before returning None

#+begin_src hy
"_wait" True
#+end_src

Dict must be in the form {"i" : user} or {"s" : user}, to use or not use the configuration files of the specified user:

#+begin_src hy
"_sudo" {}
#+end_src

If "_frozen" has a truthy value, freeze this bakery object such that another bakery object may act on it; else keep it active:

#+begin_src hy
"_frozen" False
#+end_src

A dictionary used to pass options to the ~subprocess Popen~ class:

#+begin_src hy
"_popen" {}
#+end_src

Chunk size used when reading with ~_capture = "run"~:

#+begin_src hy
"_chunk_size" 512
#+end_src

#+begin_src hy
}))
#+end_src

*** Subcommand

#+call: hash() :exports none

#+RESULTS:
: 20220111111603650875845

#+name: 20220111111603650875845
#+begin_src text
supercalifragilisticexpialidocious
#+end_src

#+begin_src hy
(setv self._sub (D {}))
(setv self._default_subcommand "<<20220111111603650875845>>")
(setv self._subcommand self._default_subcommand)
#+end_src

*** Capture Types

#+begin_src hy
(setv self._captures (, "stdout" "stderr" "both" "run"))
#+end_src

*** Return Categories

#+begin_src hy
(setv self._return_categories (,
    "stdout"
    "stderr"
    "return_code"
    "return_codes"
    "command"
    "tea"
    "verbosity"
))
#+end_src

*** Args and Kwargs

#+begin_src hy
(setv sa (.pop kwargs "_starter_args" []))
(setv ska (.pop kwargs "_starter_kwargs" {}))
(setv self._args (+
    (list args)
    (if (isinstance sa (, str bytes bytearray)) [sa] (list sa))))
(.update kwargs ska)
(setv self._kwargs kwargs))
#+end_src

** Convert to Generator

#+begin_src hy
(defn _convert_to_generator [self input] (yield-from input))
#+end_src

** Convert to ~type~

#+begin_src hy
(defn _convert_to_type [self input [_type iter]]
    (if (is input None) (return (if (in _type.__name__ (, "str" "repr")) "None" None)))
    (if (and input (isinstance input frosting))
        (cond [(isinstance (input) (, str bytes bytearray))
               (setv input [(.fill (TextWrapper :break_long_words False :break_on_hyphens False) (input))])]
              [(is (input) None) (if (in _type.__name__ (, "str" "repr")) "None" None)]
              [(isinstance (input) int) (if (in _type.__name__ (, "str" "repr"))
                                           (return (repr (input)))
                                           (return (input)))]))
    (cond [(in _type.__name__ (, "str" "repr")) (return (.join "\n" input))]
          [(in _type.__name__ (, "generator" "iter" "chain")) (return (._convert_to_generator self input))]
          [True (return (_type input))]))
#+end_src

** Subcommand Check

#+begin_src hy
(defn _subcommand_check [self subcommand]
    (cond [(= (get subcommand -1) "_") (do (setv self._sub.function (+ "_" subcommand) self._sub.unprocessed self._subcommand))]
          [(= subcommand self._subcommand) (setv self._sub.unprocessed self._subcommand)]
          [True (do (setv self._sub.unprocessed subcommand self._sub.processed (.replace subcommand "_" "-")))]))
#+end_src

** _classes

#+begin_src hy
(defn _classes [self #* args [subcommand "<<20220111111603650875845>>"] #** kwargs]
     (try (._subcommand_check self (.pop kwargs "_subcommand" subcommand))
          (._set_and_process self #* args #** kwargs)
          (return (._return_frosted_output self))
          (finally (._set self :_reset True))))
#+end_src

** _set_and_process

#+begin_src hy
(defn _set_and_process [self #* args #** kwargs]
    (._set self :_setup True)
    (setv set_with_sub (partial self._set :_subcommand self._sub.unprocessed)
          [self._args self._kwargs] (set_with_sub #* self._args :_calling True #** self._kwargs)
          [args kwargs] (set_with_sub #* args :_calling True #** kwargs))
    (set_with_sub :_final True)
    (set_with_sub :_apply True)
    (setv process_with_sub (partial self._process_args_kwargs :_subcommand self._sub.unprocessed))
    (process_with_sub #* self._args :_calling True :_starter_regular "starter" #** self._kwargs)
    (process_with_sub #* args :_calling True :_starter_regular "regular" #** kwargs)
    (process_with_sub :_final True))
#+end_src

** Operate on Frozen Bakery

# TODO: I still can't use the settings I pipe and redirect with

#+begin_src hy
(defn __assign_to_frozen [self pr _value [reversed False]]
    (setv _cls (or self._cls self)
          ilcery (isinstance _value _cls.__class__)
          value (if ilcery (or _value._cls _value) _value)
          _baked_settings (if _cls._frozen (. _cls _cls _settings final) (D {})))

    (if (not _cls._frozen)
        (do (.update (. _baked_settings [_cls._default_subcommand]) (. _cls _settings planetary [_cls._default_subcommand]))
            (.update (. _baked_settings [_cls._default_subcommand]) (. _cls _settings baked [_cls._default_subcommand]))))
    (if ilcery
        (if value._frozen
            (.update (. _baked_settings) (. value _cls _settings final [value._subcommand]))
            (do (.update (. _baked_settings [_cls._default_subcommand]) (. value _settings planetary [value._default_subcommand]))
                (.update (. _baked_settings [_cls._default_subcommand]) (. value _settings baked [value._default_subcommand])))))
    (assoc (. _baked_settings [_cls._default_subcommand]) "_frozen" False)

    (defn inner [value]
        (cond [(isinstance value (, str bytes bytearray)) (return value)]
              [(isinstance value (, tea frosting)) (return (value))]
              [True (if (not ilcery)
                        (raise (TypeError f"Sorry! `{value}' must be a string, bytes, bytearray, tea, frosting, or bakery object!"))
                        (return (or value._freezer (if value.__command (value.__command) value.__command) value._program)))]))
#+end_src

# TODO: Explain this

#+begin_src hy
    (if (isinstance value tuple)
        (if (in pr (, "<" ">" ">>"))
            (cond [(= (len value) 0) None]
                  [(= (len value) 1) (setv processed_value (inner (get value 0)))]
                  [(= (len value) 2) (if (or (isinstance (get value 0) int) (in "&" (get value 0)))
                                         (setv processed_value (inner (get value 1))
                                               pr (+ (str (get value 0)) pr))
                                         (setv processed_value (inner (get value 0))
                                               pr (str (get value 1))))]
                  [(= (len value) 3) (setv processed_value (inner (get value 1))
                                           pr (+ (get value 0) pr (get value 2)))]
                  [True (raise (TypeError f"Sorry! The tuple `{value}' may contain no more than 3 items!"))]))
        (setv processed_value (inner value)))
#+end_src

#+begin_src hy
    (cond [(in "&>" pr) (do (assoc (. _baked_settings [_cls._default_subcommand]) "_ignore_stdout" True)
                            (assoc (. _baked_settings [_cls._default_subcommand]) "_ignore_stderr" True))]
          [(in "2>" pr) (assoc (. _baked_settings [_cls._default_subcommand]) "_ignore_stderr" True)]
          [(or (in "1>" pr) (in pr (, ">" ">>" "<" "| tee" "| tee -a"))) (assoc (. _baked_settings [_cls._default_subcommand]) "_ignore_stdout" True)])

    (cond [(in ">&1" pr) (assoc (. _baked_settings [_cls._default_subcommand]) "_ignore_stdout" True)]
          [(in ">&2" pr) (assoc (. _baked_settings [_cls._default_subcommand]) "_ignore_stderr" True)])

    (setv __freezer [ (or _cls._freezer (if _cls.__command (_cls.__command) _cls.__command) _cls._program)
                      pr
                      processed_value ]
          _freezer (if reversed (py "__freezer[::-1]") __freezer)
#+end_src

Get the length of the current freezer, then the index of the pr will be plus 1 of that
(not plus 2 because the length of the freezer does not start from 0).

#+begin_src hy
          pr_index (inc (len _cls._freezer)))
#+end_src

#+begin_src hy
    (return (.__class__ _cls :_freezer _freezer
                             :_prs (, pr_index pr (get _freezer (dec pr_index)) (get _freezer (inc pr_index)))
                             :_baked_settings _baked_settings)))
#+end_src

** Create Command

#+begin_src hy
(defn _create_command [self [_cls None] [_subcommand "<<20220111111603650875845>>"]]
    (setv self._cls (._cls_check self _cls)
          self.__subcommand _subcommand
          _command (tea))

    (if self._cls._sudo
        (.append _command f"sudo -{(-> self._cls._sudo .keys iter next)} -u {(-> self._cls._sudo .values iter next)}"))

    (if self._cls._shell
        (do (.extend _command self._cls._shell "-c" "'")
            (if self._cls._run_as
                (do (.glue _command self._cls._run_as)
                    (.append self._cls._program))
                (.glue _command self._cls._program)))
        (.extend _command self._cls._run_as self._cls._program))

    (.extend _command #* (. self __cls _command final [self.__subcommand] components kwargs starter))

    (if self._cls._sub.processed (.append _command self._cls._sub.processed))

    (.extend _command
        #* (. self __cls _command final [self.__subcommand] components args starter)
        #* (. self __cls _command final [self.__subcommand] components kwargs regular)
        #* (. self __cls _command final [self.__subcommand] components args regular))

    (if self._cls._shell (.glue _command "'"))
#+end_src

To use the "_tiered" setting, bake the command in from before with all applicable
replacements replaced with "{{ b.t }}", and bake in "_tiered" to True; then when
calling the command, pass in all the arguments that are going to replace the
"{{ b.t }}" previously baked into the command.

To reset the command function, use the "splat_" function as necessary.

#+begin_src hy
(if self._cls._tiered (do
    (setv errmsg "Sorry! The number of tiered replacements must be equal to the number of arguments provided!"
          tier "{{ b.t }}"
          to_be_replaced 0)
    (for [value (.values _command)]
        (if (= value tier) (do (+= to_be_replaced 1)
                               (if (> to_be_replaced (len self.__args))
                                   (raise (TypeError errmsg))))))
    (if (< to_be_replaced (len self.__args)) (raise (TypeError errmsg)))
    (for [[index kv] (.items _command :indexed True)]
        (if (= kv.value tier) (assoc _command kv.key (get self.__args index))))))
#+end_src

#+begin_src hy
(return _command))
#+end_src

** Return Output

#+begin_src hy
(defn _return_output [self [_cls None] [_subcommand "<<20220111111603650875845>>"]]
    (setv self._cls _cls
          self.__subcommand _subcommand
          self.__command (._create_command self :_cls self._cls :_subcommand self.__subcommand))
    (if self._cls._frozen
        (return (deepcopy self._cls))
        (do (if self._cls._str (return (.__command self)))
            (if (isinstance (setx output (.__return self)) dict)
                (do (setv [_peek_value output.stderr] (peek output.stderr :return_first 2)
                        stds [ "out" "err" ])
                    (if (and _peek_value (not self._cls._ignore_stderr))
                        (raise (SystemError (.join "\n" output.stderr))))
                    (for [[std opp] (zip stds (py "stds[::-1]"))]
                        (setv stdstd (+ "std" std)
                            stdopp (+ "std" opp))
                        (if (< self._cls._verbosity 1)
                            (if (= self._cls._capture stdstd)
                                (del (get output stdopp)))))))
            (return output))))
#+end_src

*** Return

#+begin_src hy
(defn __return [self]
    (setv process (.__set_popen_partial self))
    (cond [(is self._cls._wait None) (with [p (process :stdout DEVNULL :stderr DEVNULL)]
                                           (return (if (in self._cls._type.__name__ (, "str" "repr")) "None" None)))]
          [self._cls._wait (with [p (process)]
                                 (setv _ (D {}))
                                 (for [std (, "out" "err")]
                                      (setv chained [] stdstd (+ "std" std))
                                      (if (setx output (getattr p stdstd))
                                      (for [line output] (setv chained (chain
                                           chained
                                           [(if (isinstance line (, bytes bytearray)) (.strip (.decode line "utf-8")) (.strip line))]))))
                                      (assoc _ stdstd (iter chained)))
                                 (.wait p)
                                 (if (> self._cls._verbosity 0)
                                     (setv _.returns.code p.returncode
                                           ;; _.returns.codes p.returncodes
                                           _.command.bakery (.__command self)
                                           _.command.subprocess p.args
                                           _.pid p.pid))
                                 (if (> self._cls._verbosity 1)
                                     (setv _.tea self.__command
                                           _.sub self._cls._sub
                                           _.final (D (get self._cls._command.final self.__subcommand))
                                           _.baked (D (get self._cls._command.baked self.__subcommand))
                                           _.planetary (D (get self._cls._command.planetary self.__subcommand))
                                           _.called (D (get self._cls._command.called self.__subcommand))))
                                 (if (not (and (is self._cls._n_lines.number None)
                                               (in self._cls._type.__name__ (, "str" "repr"))))
                                     (do (setv trim_part (partial trim :ordinal self._cls._n_lines.ordinal
                                                                       :number self._cls._n_lines.number
                                                                       :_type self._cls._type
                                                                       :ignore_check True))
                                         (if (in self._cls._n_lines.std (, "stdout" "both")) (setv _.stdout (trim_part :iterable _.stdout)))
                                         (if (in self._cls._n_lines.std (, "stderr" "both")) (setv _.stderr (trim_part :iterable _.stderr)))))
                                (return _))]
          [True (return (process))]))
#+end_src

*** Set Popen Partial

#+begin_src hy
(defn __set_popen_partial [self]
    (setv stdin (if (is self._cls._input None) (.get self._cls._popen "stdin" None) self._cls._input)
          stdout (cond [(= self._cls._capture "stderr") (.get self._cls._popen "stdout" DEVNULL)]
                       [(= self._cls._capture "run") (.get self._cls._popen "stdout" None)]
                       [(if self._cls._ignore_stdout (.get self._cls._popen "stdout" DEVNULL)
                                                     (.get self._cls._popen "stdout" PIPE))])
          stderr (if (= self._cls._capture "run") (.get self._cls._popen "stderr" None)
                     (if self._cls._ignore_stderr (.get self._cls._popen "stderr" DEVNULL)
                                                  (.get self._cls._popen "stderr" PIPE)))
          bufsize (.pop self._cls._popen "bufsize" -1)
          universal_newlines (.pop self._cls._popen "universal_newlines" None)
          universal_text (if (= bufsize 1) True universal_newlines)
          shell (.pop self._cls._popen "shell" self._freezer)
          command (.__command self))
    (return (partial
                Popen
                (if shell
                    (if self._freezer
                        command
                        (join (split command)))
                    (split command))
                :bufsize bufsize
                :stdin stdin
                :stdout stdout
                :stderr stderr
                :executable (if (setx exe (.get self._cls._popen "executable" None)) (fullpath exe) exe)
                :universal_newlines universal_text
                :text universal_text
                :shell shell
                #** self._cls._popen)))
#+end_src

** Frosting
*** Run Frosting

#+begin_src hy
(defn _run_frosting [self [_cls None] [_subcommand "<<20220111111603650875845>>"]]
    (setv _cls (._cls_check self _cls)
          output (._return_output _cls :_cls _cls :_subcommand _subcommand))
    (cond [self._cls._frozen (return output)]
          [_cls._print (print output)]
          [_cls._frosting (for [cat output] (setv outcat (get output cat))
                                            (if (or (isinstance outcat int)
                                                    (isinstance outcat (, str bytes bytearray)))
                                                (print f"{cat}: {outcat}")
                                                (do (if (not (in cat _cls._captures))
                                                        (print (+ cat ": ")))
                                                    (if (= cat "return_codes") (print outcat)
                                                        (for [line outcat] (print line))))))])
    (if (and (isinstance output (, dict tea frosting))
             (= (len output) 1))
        (return (-> output .values iter next))
        (return output)))
#+end_src

*** Return Frosted Output

#+begin_src hy
(defn _return_frosted_output [self [_cls None]]
    (setv _cls (._cls_check self _cls) output (._run_frosting _cls :_subcommand _cls._sub.unprocessed))
    (if (or _cls._frozen (= _cls._wait False)) (return output)
        (cond [(isinstance output (, dict tea frosting))
               (do (for [std (, "out" "err")]
                        (setv stdstd (+ "std" std))
                        (if (hasattr output stdstd) (assoc output stdstd (._convert_to_type _cls (get output stdstd) :_type _cls._type))))
                   (return output))]
              [(is _cls._wait None) (return (if (in _cls._type.__name__ (, "str" "repr")) "None" None))]
              [True (return (._convert_to_type _cls (frosting output _cls._capture) :_type _cls._type))])))
#+end_src

** Process Arguments and Keyword Arguments

#+begin_src hy
(defn _process_args_kwargs [
        self
        #* args
        [_cls None]
        [_global False]
        [_baking False]
        [_calling False]
        [_final False]
        [_subcommand "<<20220111111603650875845>>"]
        [_starter_regular "regular"]
        #** kwargs ]
    (setv self.__args args
          self.__kwargs kwargs
          self._cls _cls
          self.__global _global
          self.__baking _baking
          self.__calling _calling
          self.__final _final
          self.__subcommand _subcommand
          self.__starter_regular _starter_regular
          self.__categories (OrderedDict {
              "planetary" self.__global
              "baked" self.__baking
              "called" self.__calling
              "final" self.__final
          })
          c_count (-> self.__categories .values tuple (.count True)))
    (if (not (= c_count 1)) (let [keystring (.join ", " (.keys self.__categories))]
        (raise (TypeError f"Sorry! No combination of {keystring} may be used! Please choose only a single category!"))))
    (for [[key value] (py "tuple(self.__categories.items())[:-1]")]
        (if value (setv self.__cat key)))
    (for [cat (.keys self.__categories)]
        (for [ak (, "args" "kwargs")]
            (for [sr (, "starter" "regular")]
                (if (not (. self _cls _command [cat] [self.__subcommand] components [ak] [sr]))
                    (assoc (. self _cls _command [cat] [self.__subcommand] components [ak]) sr (tea))))))
    (if self.__final
        (do (for [ak (, "args" "kwargs")]
                (for [sr (, "starter" "regular")]
                    (for [cat (py "tuple(self.__categories.keys())[:-1]")]
                        (.extend
                            (. self _cls _command final [self.__subcommand] components [ak] [sr])
                            #* (. self _cls _command [cat] [self.__subcommand] components [ak] [sr])))))
            (if (not (= self.__subcommand self._subcommand))
                (do (if (not (. self _cls _command planetary [self._subcommand] components kwargs starter))
                        (assoc (. self _cls _command planetary [self._subcommand] components kwargs) "starter" (tea)))
                    (if (not (. self _cls _command baked [self._subcommand] components kwargs starter))
                        (assoc (. self _cls _command baked [self._subcommand] components kwargs) "starter" (tea)))
                    (.extend
                        (. self _cls _command final [self.__subcommand] components kwargs starter)
                        #* (. self _cls _command planetary [self._subcommand] components kwargs starter)
                        #* (. self _cls _command baked [self._subcommand] components kwargs starter)))))
        (do (if (or self.__args self._cls._regular_args)
                (do (+= self.__args (tuple self._cls._regular_args))
                    (.__process_args self)))
            (if self.__kwargs
                (do (.__add_kwargs self)
                    (.__process_kwargs self)))))
    (return self._cls))
#+end_src

*** Quoting

~quote_value:~

| Value   | Quoting |
|---------+---------|
| ~True~  | double  |
| ~False~ | single  |
| ~None~  | no      |

#+begin_src hy
(defn __quoting [self quote_value value]
    (cond [(or (isinstance value dict) (is quote_value None)) (return value)]
          [(not quote_value) (return f"'{value}'")]
          [True (return f"\"{value}\"")]))
#+end_src

*** Process Arguments

#+begin_src hy
(defn __process_args [self]
    (if (or (and (any (, self.__baking self.__global)) (= self.__add_replace "replace")) self.__calling)
        (assoc (. self _cls _command [self.__cat] [self.__subcommand] components args) self.__starter_regular (tea)))
    (for [arg self.__args]
        (cond [(isinstance arg dict) (.append (. self _cls _command [self.__cat] [self.__subcommand] components args [self.__starter_regular])
                                              (.__quoting self (.get arg "quotes" None) (get arg "value")))]
              [(isinstance arg (, str bytes bytearray int))
               (.append (. self _cls _command [self.__cat] [self.__subcommand] components args [self.__starter_regular]) arg)]
              [(= (. (type arg) __name__) "function") None]
              [True (raise (TypeError f"Sorry! Value '{arg}' must be a string, integer, or dictionary!"))])))
#+end_src

*** Add Keyword Arguments

#+begin_src hy
(defn __add_kwargs [self]
#+end_src

Resets or initializes the unprocessed kwargs:

#+begin_src hy
(assoc (. self _cls _command [self.__cat] [self.__subcommand] components kwargs) "unprocessed" (D {}))
#+end_src

#+begin_src hy
(for [[key value] (.items self.__kwargs)]
#+end_src

If the boolean value is "False", don't put the argument in;
for example, if "program.subcommand([...], option = False)", then the result would be "program subcommand [...]",
i.e. without "--option".

#+begin_src hy
(if (bool value)
#+end_src

#+begin_src hy
(cond [(isinstance value dict)
       (do (assoc (. self _cls _command [self.__cat] [self.__subcommand] components kwargs unprocessed [key])
                  "value"
                  (.__quoting self (.get value "quotes" None) (.get value "value" "")))
           (for [keyop (, "dashes" "fixed" "repeat" "repeat_with_values")]
                (if (in keyop (.keys values)) (assoc (. self _cls _command [self.__cat] [self.__subcommand] components kwargs unprocessed [key])
                                                     keyop
                                                     (get value keyop)))))]
      [(isinstance value (, str bytes bytearray int)) (assoc (. self _cls _command [self.__cat] [self.__subcommand] components kwargs unprocessed)
                                                             key
                                                             value)]
      [True (raise (TypeError f"Sorry! Value '{arg}' must be a string, integer, or dictionary!"))]))))
#+end_src

*** Process Keyword Arguments

#+begin_src hy
(defn __process_kwargs [self]
    (for [[key value] (.items (. self _cls _command [self.__cat] [self.__subcommand] components kwargs unprocessed))]
        (if (isinstance value dict)
            (do (setv dash (if self._cls._dos "/"
                               (if (is (.get value "dashes" None) None)
                                   (if (or (= (len key) 1) self._cls._kwarg_one_dash) "-" "--")
                                   (if (get value "dashes") "-" "--")))
                      final_key (+ dash (if (or (.get value "fixed" False)
                                                self._cls._fixed_key) key (.replace key "_" "-"))))
                (cond [(in "repeat" (.keys value))
                       (.append ( . self _cls _command [self.__cat] [self.__subcommand] components kwargs [self.__starter_regular])
                                (* [final_key] (get value "repeat")))]
                      [(in "repeat_with_values" (.keys value))
                       (do (setv value_list (lfor value
                                                  (get value "repeat_with_values")
                                                  (if (isinstance value dict) (.__quoting self (get value "quotes") (get value "value")) value)))
                           (.extend (. self _cls _command [self.__cat] [self.__subcommand] components kwargs [self.__starter_regular])
                                    (chain #* (zip (* [final_key] (len value_list)) value_list))))]
                    [True (do (.append (. self _cls _command [self.__cat] [self.__subcommand] components kwargs [self.__starter_regular])
                                       final_key)
                              (.append (. self _cls _command [self.__cat] [self.__subcommand] components kwargs [self.__starter_regular])
                                       (if (isinstance (get value "value") bool) "" (get value "value"))))]))
            (do (setv dash (if self._cls._dos "/" (if (or self._cls._kwarg_one_dash (= (len key) 1)) "-" "--"))
                      final_key (if self._cls._fixed_key key (.replace key "_" "-")))
                (.append (. self _cls _command [self.__cat] [self.__subcommand] components kwargs [self.__starter_regular]) (+ dash final_key))
                (.append (. self _cls _command [self.__cat] [self.__subcommand] components kwargs [self.__starter_regular])
                         (if (isinstance value bool) "" value))))))
#+end_src

** Set Variables

#+begin_src hy
(defn _set [
        self
        #* args
        [_cls None]
        [_global False]
        [_baking False]
        [_calling False]
        [_final False]
        [_subcommand "<<20220111111603650875845>>"]
        [_setup False]
        [_reset False]
        [_apply False]
        #** kwargs ]
    (setv self.__args args
          self.__kwargs kwargs
          self._cls _cls
          self.__subcommand _subcommand
          self.__global _global
          self.__baking _baking
          self.__calling _calling
          self.__final _final)
    (cond [_setup (.__set_defaults self)]
          [_reset (do (setv self._cls._sub (D {}))
                      (for [c1 (, "_settings" "_command")]
                           (for [c2 (, "called" "final")]
                                (assoc (getattr self._cls c1) c2 (D {})))) (.__set_defaults self))]
          [_apply (for [[key value] (.items (. self _cls _settings final [self.__subcommand]))] (setattr self._cls key value))]
          [True (do (.__set self)
                    (setv return_list [self.__args self.__kwargs])
                    (if (= self._cls self) (return return_list) (return (+ return_list [self._cls]))))]))
#+end_src

*** Set Defaults

#+begin_src hy
(defn __set_defaults [self]
    (if (not self._cls._command.planetary)
        (setv self._cls._command.planetary (or self.origin_._command.planetary (D {}))))
    (if (not self._cls._settings.planetary)
        (setv self._cls._settings.planetary (or self.origin_._settings.planetary (D {}))))
    (for [[key value] (.items self._cls._settings.defaults)] (setattr self._cls key value)))
#+end_src

*** Set

#+begin_src hy
(defn __set [self]
    (setv
#+end_src

Careful! The order of the categories here matters!

#+begin_src hy
categories (OrderedDict {
    "planetary" self.__global
    "baked" self.__baking
    "called" self.__calling
    "final" self.__final
})
#+end_src

#+begin_src hy
bategories (tuple (.values categories))
c_count (.count bategories True))
(if (not (= c_count 1)) (let [catstring (.join ", " (.keys categories))]
    (raise (TypeError f"Sorry! No combination of {catstring} may be used! Please choose only a single category!"))))
(if self._cls._sub.function (assoc self.__kwargs self._cls._sub.function True))
(if (py "any(bategories[:-1])")
    (do (setv _ {})
        (for [[key value] (py "tuple(categories.items())[:-1]")]
            (if value (do (setv cat key) (break))))
        (for [[index arg] (enumerate self.__args)]
            (if (not (and arg (isinstance arg (, str bytes bytearray int dict tea frosting))))
                (do (setv self.__args (list self.__args))
                    (assoc (. self _cls _settings [cat] [self.__subcommand]) "_frozen" True)
                    (del (get self.__args index)))))
        (defn inner [dct]
            (for [[key value] (.items dct)]
                (if (= (get key 0) "_")
                    (if (= key "_regular_kwargs")
                        (inner value)
                        (assoc (. self _cls _settings [cat] [self.__subcommand]) key value))
                    (assoc _ key value))))
        (inner self.__kwargs)

        ;; TODO: Move the args and kwargs to the baked settings dict if the bakery object is frozen
        (setv self.__kwargs (D _)))

    (do (.update (. self _cls _settings final [self.__subcommand]) (D self._cls._settings.defaults))
        (if (not (= self.__subcommand self._subcommand))
            (do (.update (. self _cls _settings final [self.__subcommand]) (D (. self _cls _settings planetary [self._subcommand])))
                (.update (. self _cls _settings final [self.__subcommand]) (D (. self _cls _settings baked [self._subcommand])))))
        (for [cat (py "tuple(categories.keys())[:-1]")]
             (.update (. self _cls _settings final [self.__subcommand]) (D (. self _cls _settings [cat] [self.__subcommand])))))))
#+end_src

** Great [Insert Country Here] Bakeoff!
*** Bake Settings and Commands

~_akar:~ args and kwargs add or replace
    - add: adds to the currently baked args and kwargs
    - replace: replaces the currently baked args and kwargs

~_sar:~ settings add or replace
    - add: adds to the currently baked settings
    - replace: replaces the currently baked settings

~_sc:~ subcommand
    - <<20220111111603650875845>>: will act on the main command

~_sr:~ ~starter~ or ~regular~ args and / or kwargs

~_g:~ whether to affect the global args, kwargs, or settings

#+begin_src hy
(defn bake_ [
        self
        #* args
        [_cls None]
        [_akar "add"]
        [_sar "add"]
        [_sc "<<20220111111603650875845>>"]
        [_sr "regular"]
        [_g False]
        #** kwargs ]
    (setv _cls (._cls_check self _cls)
          self_set (partial self._set
                            #* args
                            :_cls _cls
                            :_baking (not _g)
                            :_global _g
                            :_subcommand _sc
                            #** kwargs))
    (if (= _akar "replace")
        (assoc (. _cls _command [(if _g "planetary" "baked")]) _sc (D {})))
    (if (= _sar "replace")
        (assoc (. _cls _settings [(if _g "planetary" "baked")]) _sc (D {})))
    (._set self :_setup True)
#+end_src

Since args, kwargs, and potentially _cls are modified, and then unpacked into the following
partial, this and the similar check below said partial must remain separate.

#+begin_src hy
(if (= _cls self)
    (setv [args kwargs] (self_set))
    (setv [args kwargs _cls] (self_set)))
#+end_src

#+begin_src hy
(setv self_pak (partial self._process_args_kwargs
                        #* args
                        :_cls _cls
                        :_baking (not _g)
                        :_global _g
                        :_subcommand _sc
                        :_starter_regular _sr
                        #** kwargs))
(return (self_pak)))
#+end_src

**** Bake Settings and Commands Into All Bakeries

#+begin_src hy
(defn bake_all_ [
        self
        #* args
        [_akar "add"]
        [_sar "add"]
        [_sr "regular"]
        #** kwargs ]
    (for [store self.chain_]
        (.bake_ store
                #* args
                :_g True
                :_cls store
                :_akar _akar
                :_sar _sar
                :_sr _sr
                #** kwargs)))
#+end_src

*** Remove Baked Settings and Commands

~splat_(_all = True):~
Removes all baked args, kwargs, and settings for both the main command and
subcommands
Eg: git.splat_(_all = True)

~splat(_subcommands = ["subcommand"]):~
Removes all baked args, kwargs, and settings for just the subcommands
in the list
Eg: git.splat_(_subcommands = ["status"])

~splat(_subcommands = ["<<20220111111603650875845>>"]):~
The default; removes all baked args, kwargs, and settings for the main command
Eg: git.splat_(_subcommands = ["<<20220111111603650875845>>"])

#+begin_src hy
(defn splat_ [
        self
        [_cls None]
        [_all False]
		[_all_subcommands False]
		[_subcommands ["<<20220111111603650875845>>"]]
		[_settings False]
		[_args_kwargs False]
		[_global False]]
    (setv _cls (._cls_check self _cls)
          _pb (if _global "planetary" "baked"))
    (defn inner [cat]
        (cond [_all (assoc (getattr _cls cat) _pb (D {}))]
              [_all_subcommands (for [key (-> _cls (getattr cat) (get _pb) .keys)]
                                     (if (not (= key self._subcommand)) (assoc (. (getattr _cls cat) [_pb]) key (D {}))))]
              [True (for [sub _subcommands] (assoc (. (getattr _cls cat) [_pb]) sub (D {})))]))
    (if (and _settings _args_kwargs) (for [cat (, "_settings" "_command")] (inner cat))
        (inner (if _settings "_settings" "_command"))))
#+end_src

**** Remove Baked Settings and Commands From All Bakeries

#+begin_src hy
(defn splat_all_ [
        self
        [_all False]
        [_all_subcommands False]
        [_settings False]
        [_args_kwargs False]]
    (for [store self.chain_] (.splat_ store
                                      :_cls store
                                      :_all _all
                                      :_all_subcommands _all_subcommands
                                      :_settings _settings
                                      :_args_kwargs _args_kwargs
                                      :_global True)))
#+end_src

*** Class Check

#+begin_src hy
(defn _cls_check [self _cls] (return (if (isinstance _cls self.__class__) _cls self)))
#+end_src

** Magic Methods

#+call: hash() :exports none

#+RESULTS:
: 20220101211017222161829

#+name: 20220101211017222161829
#+begin_src emacs-lisp :var *list='nil
(setq left (if *list "\\\"" "[")
      right (if *list "\\\"" " None]"))
(string-join (mapcar #'(lambda (arg) (interactive) (concat left arg right)) '(
    "_func"
    "_rab"
    "_raa"
    "_sa"
    "_sk"
)) "\n")
#+end_src

Adapted from [[https://realpython.com/primer-on-python-decorators/][Primer on Python Decorators]]:

#+call: hash() :exports none

#+RESULTS:
: 20220101204858374153059

#+name: 20220101204858374153059
#+begin_src emacs-lisp :var subcommand='nil
(format-spec "(if (or (.get dwargs \"_decorator\" False) (.get dwargs \"_d\" False))
    (do (defn wrapper [func]
            #@((wraps func)
                (defn wrapped [#* args #** kwargs]
                    (return (._classes self
                        %s
                        :_starter_args (or _sa [])
                        :_starter_kwargs (or _sk {})
                        :_regular_args (chain
                            (or _rab [])
                            (func #* args #** kwargs)
                            (or _raa []))
                        :_regular_kwargs dwargs))))
            (return wrapped))
        (if (is _func None) (return wrapper)
            (return (wrapper _func))))
    (do (for [dwarg (,
                <<20220101211017222161829(*list='t)>>
            )] (.pop dwargs dwarg None))
        (return (._classes self #* dargs %s #** dwargs))))"
    `((?s . ,(if subcommand ":subcommand subcommand" ""))))
#+end_src

*** __call__

#+begin_src hy
(defn __call__ [
        self
        #* dargs
        <<20220101211017222161829()>>
        #** dwargs ]
    <<20220101204858374153059()>>)
#+end_src

*** __getattr__

#+begin_src hy
(defn __getattr__ [self subcommand]
    (if (.startswith subcommand "_")
        (return (D {}))
        (do (defn inner [
                    #* dargs
                    <<20220101211017222161829()>>
                    #** dwargs ]
                <<20220101204858374153059(subcommand='t)>>)
            (return inner))))
#+end_src

*** __copy__

Adapted from [[https://gist.github.com/shadowrylander/a4d861fc37d381b8edc4b8e7793000d1][here]]:

#+begin_src hy
(defn __copy__ [self]
#+end_src

#+begin_quote
Create a new instance
#+end_quote

#+begin_src hy
    (setv cls self.__class__
          result (.__new__ cls cls)
#+end_src

#+begin_quote
Get all ~__slots__~ of the derived class
#+end_quote

#+begin_src hy
          slots (.from_iterable chain (lfor s self.__class__.__mro__ (getattr s "__slots__" []))))
#+end_src

#+begin_quote
Copy all attributes
#+end_quote

#+begin_src hy
    (for [var slots] (if (not (in var (, "__weakref__"))) (setattr result var (copy (getattr self var)))))
    (.update result.__dict__ self.__dict__)
#+end_src

#+begin_quote
Return updated instance
#+end_quote

#+begin_src hy
    (return result))
#+end_src

*** __deepcopy__

Adapted from [[https://gist.github.com/shadowrylander/a4d861fc37d381b8edc4b8e7793000d1][here]]:

#+begin_src hy
(defn __deepcopy__ [self memo]
#+end_src

#+begin_quote
Create a new instance
#+end_quote

#+begin_src hy
    (setv cls self.__class__
          result (.__new__ cls cls))
#+end_src

#+begin_quote
Don't copy self reference
#+end_quote

#+begin_src hy
    (assoc memo (id self) result)
#+end_src

#+begin_quote
Don't copy the cache - if it exists
#+end_quote

#+begin_src hy
    (if (and (hasattr self "_cache") self._cache) (assoc memo (id self._cache) (.__new__ self._cache dict)))
#+end_src

#+begin_quote
Get all ~__slots__~ of the derived class
#+end_quote

#+begin_src hy
    (setv slots (.from_iterable chain (lfor s self.__class__.__mro__ (getattr s "__slots__" []))))
#+end_src

#+begin_quote
Deep copy all other attributes
#+end_quote

#+begin_src hy
    (for [var slots] (if (not (in var (, "__weakref__"))) (setattr result var (deepcopy (getattr self var) memo))))
    (for [[k v] (.items self.__dict__)] (setattr result k (deepcopy v memo)))
#+end_src

#+begin_quote
Return updated instance
#+end_quote

#+begin_src hy
    (return result))
#+end_src

*** __iter__

#+begin_src hy
(defn __iter__ [self]
    (setv self.n 0)
    (._subcommand_check self self._subcommand)
    (._set_and_process self)
    (cond [(isinstance (setx output (._return_frosted_output self)) dict)
           (setv self.__next_output (list (get output (if (= self._capture "stderr") "stderr" "stdout"))))]
          [(isinstance output (, str bytes bytearray)) (setv self.__next_output [output])]
          [True (setv self.__next_output (list output))])
    (return self))
#+end_src

*** __next__

#+begin_src hy
(defn __next__ [self] (if (< self.n (len self.__next_output))
    (do (+= self.n 1) (return (get self.__next_output (- self.n 1))))
    (raise StopIteration)))
#+end_src

*** __str__

#+begin_src hy
(defn __str__ [self]
    (setv output (._classes self :_type str))
    (return (if (not (in (. (type output) __name__) (, "str" "repr"))) "Sorry! The bakery is currently frozen!" output)))
#+end_src

*** __repr__

#+begin_src hy
(defn __repr__ [self]
    (setv output (._classes self :_type repr))
    (return (if (not (in (. (type output) __name__) (, "str" "repr"))) "Sorry! The bakery is currently frozen!" output)))
#+end_src

*** __or__

#+begin_src hy
(defn __or__ [self value] (return (.__assign_to_frozen self "|" value)))
#+end_src

*** __ror__

#+begin_src hy
(defn __ror__ [self value] (return (.__assign_to_frozen self "|" value :reversed True)))
#+end_src

*** __xor__

#+begin_src hy
(defn __xor__ [self value] (return (.__assign_to_frozen self "| tee" value)))
#+end_src

*** __rxor__

#+begin_src hy
(defn __rxor__ [self value] (return (.__assign_to_frozen self "| tee" value :reversed True)))
#+end_src

*** __add__

#+begin_src hy
(defn __add__ [self value] (return (.__assign_to_frozen self "| tee -a" value)))
#+end_src

*** __radd__

#+begin_src hy
(defn __radd__ [self value] (return (.__assign_to_frozen self "| tee -a" value :reversed True)))
#+end_src

*** __lshift__

#+begin_src hy
(defn __lshift__ [self value] (return (.__assign_to_frozen self "<" value)))
#+end_src

*** __lt__

#+begin_src hy
(defn __lt__ [self value] (return (.__assign_to_frozen self "<" value)))
#+end_src

*** __rlshift__

#+begin_src hy
(defn __rlshift__ [self value] (return (.__assign_to_frozen self "<" value :reversed True)))
#+end_src

*** __gt__

#+begin_src hy
(defn __gt__ [self value] (return (.__assign_to_frozen self ">" value)))
#+end_src

*** __rshift__

#+begin_src hy
(defn __rshift__ [self value] (return (.__assign_to_frozen self ">" value)))
#+end_src

*** __rrshift__

#+begin_src hy
(defn __rrshift__ [self value] (return (.__assign_to_frozen self ">" value :reversed True)))
#+end_src

*** __matmul__

#+begin_src hy
(defn __matmul__ [self value] (return (.__assign_to_frozen self ">>" value)))
#+end_src

*** __rmatmul__

#+begin_src hy
(defn __rmatmul__ [self value] (return (.__assign_to_frozen self ">>" value :reversed True)))
#+end_src

*** __enter__

#+begin_src hy
(defn __enter__ [self] (return self))
#+end_src

*** __exit__

#+begin_src hy
(defn __exit__ [self exc_type exc_val exc_tb] None))
#+end_src

* __getattr__

#+begin_src hy
(defn __getattr__ [_program]
    (if (= _program "__path__") (raise AttributeError))
    (try (return (milcery :_program _program))
         (except [e [Exception]] (return e))))
#+end_src